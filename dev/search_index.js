var documenterSearchIndex = {"docs":
[{"location":"methods/#Reference","page":"Manual","title":"Reference","text":"","category":"section"},{"location":"methods/","page":"Manual","title":"Manual","text":"Modules = [AutoBZCore]\nOrder   = [:type, :function]","category":"page"},{"location":"methods/#AutoBZCore.FourierIntegrand","page":"Manual","title":"AutoBZCore.FourierIntegrand","text":"FourierIntegrand(f, s::AbstractFourierSeries, p...)\n\nA type generically representing an integrand f whose entire dependence on the variables of integration is in a Fourier series s, and which may also accept some input parameters p. The caller must know that their function, f, will be evaluated at many points, x, in the following way: f(s(x), p...). Therefore the caller is expected to know the type of s(x) (hint: eltype(s)) and the layout of the parameters in the tuple p (hint: it should correspond to the arguments of the function). This type is optimized for the IAI and PTR routines.\n\n\n\n\n\n","category":"type"},{"location":"methods/#AutoBZCore.IntegralSolver","page":"Manual","title":"AutoBZCore.IntegralSolver","text":"IntegralSolver(f, lb, ub, alg; abstol=0, reltol=sqrt(eps()), maxiters=typemax(Int))\nIntegralSolver(f, bz::SymmetricBZ, alg::AbstractAutoBZAlgorithm; kwargs...)\n\nConstructs a functor that solves an integral of f over the given domain (e.g. lb to ub or a bz) using the given alg to within the given tolerances. Calling this functor, fun with parameters p using the syntax fun(p) returns the estimated integral I. Under the hood, this uses the Integrals.jl interface for defining an IntegralProblem, so f must \n\nAlso, the types Integrand and FourierIntegrand allow for providing a partial set of parameters so that the IntegralSolver can interface easily with other algorithms, such as root-finding and interpolation.\n\n\n\n\n\n","category":"type"},{"location":"methods/#AutoBZCore.Integrand","page":"Manual","title":"AutoBZCore.Integrand","text":"Integrand(f, p...)\n\nRepresent an integrand with a partial collection of parameters p. When the Integrand is invoked with one argument, e.g. int(x), it evaluates f(x, p...). However when invoked with two arguments, as in an IntegralProblem, e.g. int(x, p2), it evaluates the union of parameters f(x, p..., p2...). This allows for convenient parametrization of the integrand.\n\n\n\n\n\n","category":"type"},{"location":"methods/#AutoBZCore.SymmetricBZ","page":"Manual","title":"AutoBZCore.SymmetricBZ","text":"SymmetricBZ(A, B, lims::AbstractLimits, syms; atol=sqrt(eps()))\n\nData type representing a Brillouin zone reduced by a set of symmetries, syms with iterated integration limits lims, both of which are assumed to be in the lattice basis (since the Fourier series is). A and B should be identically-sized square matrices containing the real and reciprocal basis vectors in their columns. lims should be limits compatible with the IteratedIntegration package that represent the BZ in fractional lattice coordinates (e.g. the full BZ with vertices (0,0,0) & (1,1,1)). syms should be a collection of symmetries compatible with AutoSymPTR and the symmetry operators should be in the lattice basis (if necessary, rotate them from the Cartesian basis).\n\n\n\n\n\n","category":"type"},{"location":"methods/#AutoBZCore.FullBZ","page":"Manual","title":"AutoBZCore.FullBZ","text":"FullBZ(A, B=canonical_reciprocal_basis(A); atol=sqrt(eps()))\n\nConstructs a SymmetricBZ with trivial symmetries.\n\n\n\n\n\n","category":"function"},{"location":"methods/#AutoBZCore.batchparam-Tuple{Any, Any}","page":"Manual","title":"AutoBZCore.batchparam","text":"batchparam(xs, nthreads)\n\nIf the cost of a calculation smoothly varies with the parameters xs, then batch xs into nthreads groups where the ith element of group j is xs[j+(i-1)*nthreads]\n\n\n\n\n\n","category":"method"},{"location":"methods/#AutoBZCore.batchsolve","page":"Manual","title":"AutoBZCore.batchsolve","text":"batchsolve(f, ps, [T=Base.promote_op(f, eltype(ps))]; nthreads=Threads.nthreads())\n\nEvaluate the IntegralSolver f at each of the parameters ps in parallel. Returns a vector containing the evaluated integrals I. This is a form of multithreaded broadcasting.\n\n\n\n\n\n","category":"function"},{"location":"methods/#AutoBZCore.symmetrize-Tuple{Any, SymmetricBZ, Vararg{Any, N} where N}","page":"Manual","title":"AutoBZCore.symmetrize","text":"symmetrize(f, ::SymmetricBZ, xs...)\nsymmetrize(f, ::SymmetricBZ, x::Number)\n\nTransform x by the symmetries of the parametrization used to reduce the domain, thus mapping the value of x on the parametrization to the full domain.\n\n\n\n\n\n","category":"method"},{"location":"methods/#AutoSymPTR.alloc_autobuffer-Union{Tuple{T}, Tuple{N}, Tuple{AbstractFourierSeries{N, T} where T, Type{T}, Nothing}} where {N, T}","page":"Manual","title":"AutoSymPTR.alloc_autobuffer","text":"alloc_autobuffer(f::AbstractFourierSeries, ::Type{T}, syms)\n\nInitialize an empty buffer of PTR rules with pre-evaluated Fourier series evaluated on a domain of type T with symmetries syms\n\n\n\n\n\n","category":"method"},{"location":"#AutoBZCore.jl","page":"Home","title":"AutoBZCore.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AutoBZCore","category":"page"},{"location":"#AutoBZCore","page":"Home","title":"AutoBZCore","text":"The package providing the functionality and abstractions for AutoBZ.jl. It provides both SymmetricBZ, which is a type that stores information about the Brillouin zone (BZ), and FourierIntegrator, a type that provides a functor interface to compute user-defined Brillouin zone integrals depending on Wannier-interpolated quantities. The package integrates with FourierSeriesEvaluators, IteratedIntegration, and AutoSymPTR to provide a generic interface to efficient algorithms for BZ integration.\n\nFor example, computing the local Green's function can be done as follows:\n\nusing LinearAlgebra\nusing FourierSeriesEvaluators\nusing AutoBZCore\n\ngloc_integrand(h_k, η, ω) = inv(complex(ω,η)*I-h_k)     # define integrand evaluator\nh = FourierSeries([0.5, 0.0, 0.5]; offset=-2)           # construct cos(k) 1D integer lattice Hamiltonian\nbz = FullBZ(2pi*I(1))                                   # construct BZ from lattice vectors A=2pi*I\nintegrand = FourierIntegrand(gloc_integrand, h, 0.1)    # construct integrand with Fourier series h and parameter η=0.1\nalg = IAI()                                             # choose integration algorithm (also AutoPTR() and PTR())\ngloc = IntegralSolver(integrand, bz, alg; abstol=1e-3)  # construct a solver for gloc to within specified tolerance\ngloc(0.0)                                               # evaluate gloc at frequency ω=0.0\n\nnote: Assumptions\nAutoBZCore assumes that all calculations occur in the reciprocal lattice basis, since that is the basis in which Wannier interpolants are most efficiently described. This means that user-provided integration limits and symmetries should be in the reciprocal lattice basis and additionally they should be in fractional coordinates (e.g. the BZ in these coordinates has vertices (0,0,0) and (1,1,1)). All symmetry transformations must be dealt with by the user, who can specialize the symmetrize routine to automate that step.\n\n\n\n\n\n","category":"module"}]
}
