var documenterSearchIndex = {"docs":
[{"location":"extensions/#Package-extensions","page":"Extensions","title":"Package extensions","text":"","category":"section"},{"location":"extensions/#SymmetryReduceBZ.jl","page":"Extensions","title":"SymmetryReduceBZ.jl","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Loading SymmetryReduceBZ.jl provides a specialized method of load_bz that when provided atom species and positions can compute the IBZ.","category":"page"},{"location":"extensions/#HDF5.jl","page":"Extensions","title":"HDF5.jl","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Loading HDF5.jl provides a specialized method of batchsolve that accepts an H5 archive or group in the first argument and writes the integral results and timings to a dataset.","category":"page"},{"location":"extensions/#WannierIO.jl","page":"Extensions","title":"WannierIO.jl","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Loading WannierIO.jl provides a specialized method of load_bz that loads the BZ defined in a seedname.wout file.","category":"page"},{"location":"extensions/#AtomsBase.jl","page":"Extensions","title":"AtomsBase.jl","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Loading AtomsBase.jl provides a specialized method of load_bz to load the BZ of an AtomsBase.AbstractSystem","category":"page"},{"location":"integrands/#Integrands","page":"Integrands","title":"Integrands","text":"","category":"section"},{"location":"integrands/","page":"Integrands","title":"Integrands","text":"The design of AutoBZCore.jl uses multiple dispatch to provide multiple interfaces for user integrands that allow various optimizations to be compatible with a common interface for solvers. Unfortunately, not all algorithms support all integrands, since the underlying libraries must support the same interface.","category":"page"},{"location":"integrands/#Functions","page":"Integrands","title":"Functions","text":"","category":"section"},{"location":"integrands/","page":"Integrands","title":"Integrands","text":"A user can pass an integrand of the form f(x,p) in the same way as in Integrals.jl","category":"page"},{"location":"integrands/#ParameterIntegrand","page":"Integrands","title":"ParameterIntegrand","text":"","category":"section"},{"location":"integrands/","page":"Integrands","title":"Integrands","text":"AutoBZCore.ParameterIntegrand","category":"page"},{"location":"integrands/#AutoBZCore.ParameterIntegrand","page":"Integrands","title":"AutoBZCore.ParameterIntegrand","text":"ParameterIntegrand(f, args...; kwargs...)\n\nRepresent an integrand with a partial collection of parameters p. When the ParameterIntegrand is invoked with one argument, e.g. int(x), it evaluates f(x, p...; kwargs...). However when invoked with two arguments, as in an IntegralProblem, e.g. int(x, p2), it evaluates the union of parameters f(x, p..., p2...; kwargs...). This allows for convenient parametrization of the integrand.\n\n\n\n\n\n","category":"type"},{"location":"integrands/#InplaceIntegrand","page":"Integrands","title":"InplaceIntegrand","text":"","category":"section"},{"location":"integrands/","page":"Integrands","title":"Integrands","text":"AutoBZCore.InplaceIntegrand","category":"page"},{"location":"integrands/#AutoBZCore.InplaceIntegrand","page":"Integrands","title":"AutoBZCore.InplaceIntegrand","text":"InplaceIntegrand(f!, result::AbstractArray)\n\nConstructor for a InplaceIntegrand accepting an integrand of the form f!(y,x,p). The caller also provides an output array needed to store the result of the quadrature. Intermediate y arrays are allocated during the calculation, and the final result is may or may not be written to result, so use the IntegralSolution immediately after the calculation to read the result, and don't expect it to persist if the same integrand is used for another calculation.\n\n\n\n\n\n","category":"type"},{"location":"integrands/#BatchIntegrand","page":"Integrands","title":"BatchIntegrand","text":"","category":"section"},{"location":"integrands/","page":"Integrands","title":"Integrands","text":"AutoBZCore.BatchIntegrand","category":"page"},{"location":"integrands/#AutoBZCore.BatchIntegrand","page":"Integrands","title":"AutoBZCore.BatchIntegrand","text":"BatchIntegrand(f!, y::AbstractArray, x::AbstractVector, max_batch=typemax(Int))\n\nConstructor for a BatchIntegrand accepting an integrand of the form f!(y,x,p) = y .= f!.(x, Ref(p)) that can evaluate the integrand at multiple quadrature nodes using, for example, threads, the GPU, or distributed-memory. The max_batch keyword is a soft limit on the number of nodes passed to the integrand. The buffers y,x must both be resize!-able since the number of evaluation points may vary between calls to f!.\n\n\n\n\n\n","category":"type"},{"location":"integrands/#FourierIntegrand","page":"Integrands","title":"FourierIntegrand","text":"","category":"section"},{"location":"integrands/","page":"Integrands","title":"Integrands","text":"AutoBZCore.FourierIntegrand","category":"page"},{"location":"integrands/#AutoBZCore.FourierIntegrand","page":"Integrands","title":"AutoBZCore.FourierIntegrand","text":"FourierIntegrand(f, w::FourierWorkspace, args...; kws...)\n\nConstructs an integrand of the form f(FourierValue(x,w(x)), args...; kws...) where the Fourier series in w is evaluated efficiently, i.e. one dimension at a time, with compatible algorithms.\n\n\n\n\n\nFourierIntegrand(f, s::AbstractFourierSeries, args...; kws...)\n\nOuter constructor for FourierIntegrand that wraps the Fourier series s into a single-threaded FourierWorkspace.\n\n\n\n\n\n","category":"type"},{"location":"integrands/#NestedBatchIntegrand","page":"Integrands","title":"NestedBatchIntegrand","text":"","category":"section"},{"location":"integrands/","page":"Integrands","title":"Integrands","text":"AutoBZCore.NestedBatchIntegrand","category":"page"},{"location":"integrands/#AutoBZCore.NestedBatchIntegrand","page":"Integrands","title":"AutoBZCore.NestedBatchIntegrand","text":"NestedBatchIntegrand(f::Tuple, y::AbstractVector, x::AbstractVector, max_batch::Integer)\n\nAn integrand type intended for multi-threaded evaluation of NestedQuad. The caller provides a tuple f of worker functions that can evaluate the same integrand on different threads, so as to avoid race conditions. These workers can also be NestedBatchIntegrands depending on if the user wants to parallelize the integration at multiple levels of nesting. The other arguments are the same as for BatchIntegrand.\n\n\n\n\n\n","category":"type"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following are several examples of how to use the algorithms and integrands provided by AutoBZCore.jl.","category":"page"},{"location":"examples/#IntegralSolver","page":"Examples","title":"IntegralSolver","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"AutoBZCore.IntegralSolver","category":"page"},{"location":"examples/#AutoBZCore.IntegralSolver","page":"Examples","title":"AutoBZCore.IntegralSolver","text":"IntegralSolver(cache::IntegralCache)\n\nThis struct is a functor that solves an integral problem as a function of the problem parameters for a given algorithms and tolerances.\n\n\n\n\n\n","category":"type"},{"location":"examples/#Density-of-states","page":"Examples","title":"Density of states","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The repo's demo on density of states provides a complete example of how to compute and interpolate an integral as a function of its parameters.","category":"page"},{"location":"examples/#Green's-function","page":"Examples","title":"Green's function","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For example, computing the local Green's function can be done as follows:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using LinearAlgebra\nusing FourierSeriesEvaluators\nusing AutoBZCore\n\ngloc_integrand(k, h; η, ω) = inv(complex(ω,η)*I-h(k))   # define integrand evaluator\nh = FourierSeries([0.5, 0.0, 0.5]; period=1, offset=-2) # construct cos(2πk) 1D integer lattice Hamiltonian\nintegrand = ParameterIntegrand(gloc_integrand, h, η=0.1)         # construct integrand with Fourier series h and parameter η=0.1\nprob = IntegralProblem(integrand, 0, 1)                 # setup the integral problem\nalg = QuadGKJL()                                        # choose integration algorithm (also AutoPTR() and PTR())\ngloc = IntegralSolver(prob, alg; abstol=1e-3)           # construct a solver for gloc to within specified tolerance\ngloc(ω=0.0)                                             # evaluate gloc at frequency ω=0.0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"When performing integrals over multiple dimensions, it is much more efficient to evaluate a Fourier series one dimension at a time. This capability is provided by FourierIntegrand and is illustrated below","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"gloc_integrand(h_k::FourierValue; η, ω) = inv(complex(ω,η)*I-h_k.s)     # define integrand evaluator\nh = FourierSeries([0.0; 0.5; 0.0;; 0.5; 0.0; 0.5;; 0.0; 0.5; 0.0]; period=1, offset=-2) # construct cos(2πk) 1D integer lattice Hamiltonian\nbz = load_bz(FBZ(2), 2pi*I(2))                          # construct BZ from lattice vectors A=2pi*I\nintegrand = FourierIntegrand(gloc_integrand, h, η=0.1)  # construct integrand with Fourier series h and parameter η=0.1\nprob = IntegralProblem(integrand, bz)                   # setup the integral problem\nalg = IAI()                                             # choose integration algorithm (also AutoPTR() and PTR())\ngloc = IntegralSolver(prob, alg; abstol=1e-3)           # construct a solver for gloc to within specified tolerance\ngloc(ω=0.0)                                             # evaluate gloc at frequency ω=0.0","category":"page"},{"location":"examples/#SciML-interface","page":"Examples","title":"SciML interface","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"AutoBZCore.jl replicates the Integrals.jl interface, but does not export it.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AutoBZCore: IntegralProblem, init, solve!\n\nprob = IntegralProblem((x,p) -> sin(p*x), 0, 1, 0.3)\ncache = init(prob, QuadGKJL())\nsolve!(cache)   # 0.14887836958131329\n\n# solve again at a new parameter\ncache.p = 0.4\nsolve!(cache)   # 0.1973475149927873\n","category":"page"},{"location":"examples/#Batched-evaluation","page":"Examples","title":"Batched evaluation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The routine batchsolve allows multi-threaded evaluation of an IntegralSolver at many parameter points.","category":"page"},{"location":"reference/#Function-reference","page":"Reference","title":"Function reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The following are functions exported by AutoBZCore.jl","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"AutoBZCore.load_bz\nAutoBZCore.batchsolve\nAutoBZCore.paramzip\nAutoBZCore.paramproduct","category":"page"},{"location":"reference/#AutoBZCore.load_bz","page":"Reference","title":"AutoBZCore.load_bz","text":"load_bz(::AbstractBZ, T::Type)\nload_bz(::AbstractBZ, A::AbstractMatrix, [B::AbstractMatrix])\n\nInterface to loading Brillouin zones\n\nnote: Assumptions\nAutoBZCore assumes that all calculations occur in the reciprocal lattice basis, since that is the basis in which Wannier interpolants are most efficiently described. See SymmetricBZ for details. We also assume that the integrands are cheap to evaluate, which is why we provide adaptive methods in the first place, so that return types can be determined at runtime (and mechanisms are in place for compile time as well)\n\n\n\n\n\n","category":"function"},{"location":"reference/#AutoBZCore.batchsolve","page":"Reference","title":"AutoBZCore.batchsolve","text":"batchsolve(f::IntegralSolver, ps::AbstractArray, [T]; nthreads=Threads.nthreads())\n\nEvaluate the IntegralSolver f at each of the parameters ps in parallel. Returns an array similar to ps containing the evaluated integrals I. This is a form of multithreaded broadcasting. Providing the return type f(eltype(ps))::T is optional, but will help in case inference of that type fails.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Brillouin-zone-kinds","page":"Reference","title":"Brillouin-zone kinds","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"AutoBZCore.FBZ\nAutoBZCore.IBZ\nAutoBZCore.InversionSymIBZ\nAutoBZCore.CubicSymIBZ","category":"page"},{"location":"reference/#AutoBZCore.FBZ","page":"Reference","title":"AutoBZCore.FBZ","text":"FBZ{N} <: AbstractBZ\n\nSingleton type representing first/full Brillouin zones of N dimensions. By default, N is nothing and the dimension is obtained from input files.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.IBZ","page":"Reference","title":"AutoBZCore.IBZ","text":"IBZ <: AbstractBZ\n\nSingleton type representing irreducible Brillouin zones. Load SymmetryReduceBZ.jl to use this.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.InversionSymIBZ","page":"Reference","title":"AutoBZCore.InversionSymIBZ","text":"InversionSymIBZ{N} <: AbstractBZ\n\nSingleton type representing Brillouin zones with full inversion symmetry\n\nwarning: Assumptions\nOnly expect this to work for systems with orthogonal lattice vectors\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.CubicSymIBZ","page":"Reference","title":"AutoBZCore.CubicSymIBZ","text":"CubicSymIBZ{N} <: AbstractBZ\n\nSingleton type representing Brillouin zones with full cubic symmetry\n\nwarning: Assumptions\nOnly expect this to work for systems with orthogonal lattice vectors\n\n\n\n\n\n","category":"type"},{"location":"reference/#Symmetry-representations","page":"Reference","title":"Symmetry representations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"AutoBZCore.SymRep\nAutoBZCore.TrivialRep\nAutoBZCore.UnknownRep","category":"page"},{"location":"reference/#AutoBZCore.SymRep","page":"Reference","title":"AutoBZCore.SymRep","text":"SymRep(f)\n\nSymRep specifies the symmetry representation of the integral of the function f. When you define a new integrand, you can choose to implement this trait to specify how the integral is transformed under the symmetries of the lattice in order to map the integral of f on the IBZ to the result for the FBZ.\n\nNew types for SymRep should also extend a corresponding method for AutoBZCore.symmetrize_.\n\n\n\n\n\n","category":"function"},{"location":"reference/#AutoBZCore.TrivialRep","page":"Reference","title":"AutoBZCore.TrivialRep","text":"TrivialRep()\n\nSymmetry representation of objects with trivial transformation under the group.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.UnknownRep","page":"Reference","title":"AutoBZCore.UnknownRep","text":"UnknownRep()\n\nFallback symmetry representation for array types without a user-defined SymRep.\n\n\n\n\n\n","category":"type"},{"location":"#AutoBZCore.jl","page":"Home","title":"AutoBZCore.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"note: Work in progress\nWe apologize for the inconvenience as we continue improving the documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"AutoBZCore","category":"page"},{"location":"#AutoBZCore","page":"Home","title":"AutoBZCore","text":"A package providing a common interface to integration algorithms intended for applications including Brillouin-zone integration and Wannier interpolation. Its design is influenced by high-level libraries like Integrals.jl, and it makes use of Julia's multiple dispatch to provide the same interface for integrands with optimized inplace, batched, and Fourier series evaluation.\n\nQuickstart\n\nAs a first example, we integrate sine over [0,1] as a function of its period.\n\njulia> using AutoBZCore\n\njulia> f = IntegralSolver((x,p) -> sin(p*x), 0, 1, QuadGKJL());\n\njulia> f(0.3) # solves the integral of sin(p*x) over [0,1] with p=0.3\n0.14887836958131329\n\nNotice that we construct an IntegralSolver object that we can evaluate at different parameters with a function-like interface. For more examples, see the documentation.\n\nFeatures\n\nSpecial integrand interfaces\n\nParameterIntegrand: allows user integrand to use keyword arguments\nInplaceIntegrand: allows an integrand to write its result inplace to an array\nBatchIntegrand: allows user-side parallelization on e.g. shared memory, distributed memory, or the gpu\nFourierIntegrand: efficient evaluation of Fourier series for cubatures with hierachical grids\n\nQuadrature algorithms:\n\nTrapezoidal rule and FastGaussQuadrature.jl: QuadratureFunction\nh-adaptive quadrature (Gauss-Kronrod): QuadGKJL\nh-adaptive cubature (Genz-Malik): HCubatureJL\np-adaptive, symmetrized Monkhorst-Pack: AutoSymPTRJL\n\nMeta-Algorithms:\n\nIterated integration: NestedQuad\nIntegrand evaluation counter: EvalCounter\n\nExtended help\n\nIf you experience issues with AutoBZCore.jl, please report a bug on the GitHub page to contact the developers.\n\n\n\n\n\n","category":"module"},{"location":"algorithms/#Quadrature","page":"Algorithms","title":"Quadrature","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"AutoBZCore.QuadratureFunction\nAutoBZCore.QuadGKJL\nAutoBZCore.AuxQuadGKJL\nAutoBZCore.ContQuadGKJL\nAutoBZCore.MeroQuadGKJL","category":"page"},{"location":"algorithms/#AutoBZCore.QuadratureFunction","page":"Algorithms","title":"AutoBZCore.QuadratureFunction","text":"QuadratureFunction(; fun=trapz, npt=50, nthreads=Threads.nthreads())\n\nQuadrature rule for the standard interval [-1,1] computed from a function x, w = fun(npt). The nodes and weights should be set so the integral of f on [-1,1] is sum(w .* f.(x)). The default quadrature rule is trapz, although other packages provide rules, e.g.\n\nusing FastGaussQuadrature\nalg = QuadratureFunction(fun=gausslegendre, npt=100)\n\nnthreads sets the numbers of threads used to parallelize the quadrature only when the integrand is a BatchIntegrand, in which case the user must parallelize the integrand evaluations. For no threading set nthreads=1.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.QuadGKJL","page":"Algorithms","title":"AutoBZCore.QuadGKJL","text":"QuadGKJL(; order = 7, norm = norm)\n\nDuplicate of the QuadGKJL provided by Integrals.jl.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.AuxQuadGKJL","page":"Algorithms","title":"AutoBZCore.AuxQuadGKJL","text":"AuxQuadGKJL(; order = 7, norm = norm)\n\nGeneralization of the QuadGKJL provided by Integrals.jl that allows for AuxValued integrands for auxiliary integration and multi-threaded evaluation with the batch argument to IntegralProblem\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.ContQuadGKJL","page":"Algorithms","title":"AutoBZCore.ContQuadGKJL","text":"ContQuadGKJL(; order = 7, norm = norm, rho = 1.0, rootmeth = IteratedIntegration.ContQuadGK.NewtonDeflation())\n\nA 1d contour deformation quadrature scheme for scalar, complex-valued integrands. It defaults to regular quadgk behavior on the real axis, but if it finds a root of 1/f nearby, in the sense of Bernstein ellipse for the standard segment [-1,1] with semiaxes cosh(rho) and sinh(rho), on either the upper/lower half planes, then it dents the contour away from the presumable pole.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.MeroQuadGKJL","page":"Algorithms","title":"AutoBZCore.MeroQuadGKJL","text":"MeroQuadGKJL(; order = 7, norm = norm, rho = 1.0, rootmeth = IteratedIntegration.MeroQuadGK.NewtonDeflation())\n\nA 1d pole subtraction quadrature scheme for scalar, complex-valued integrands that are meromorphic. It defaults to regular quadgk behavior on the real axis, but if it finds nearby roots of 1/f, in the sense of Bernstein ellipse for the standard segment [-1,1] with semiaxes cosh(rho) and sinh(rho), it attempts pole subtraction on that segment.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#Cubature","page":"Algorithms","title":"Cubature","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"AutoBZCore.HCubatureJL\nAutoBZCore.MonkhorstPack\nAutoBZCore.AutoSymPTRJL","category":"page"},{"location":"algorithms/#AutoBZCore.HCubatureJL","page":"Algorithms","title":"AutoBZCore.HCubatureJL","text":"HCubatureJL(; norm=norm, initdiv=1)\n\nA copy of HCubatureJL from Integrals.jl.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.MonkhorstPack","page":"Algorithms","title":"AutoBZCore.MonkhorstPack","text":"MonkhorstPack(; npt=50, syms=nothing, nthreads=Threads.nthreads())\n\nPeriodic trapezoidal rule with a fixed number of k-points per dimension, npt, using the PTR rule from AutoSymPTR.jl. nthreads sets the numbers of threads used to parallelize the quadrature only when the integrand is a BatchIntegrand, in which case the user must parallelize the integrand evaluations. For no threading set nthreads=1. The caller should check that the integral is converged w.r.t. npt.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.AutoSymPTRJL","page":"Algorithms","title":"AutoBZCore.AutoSymPTRJL","text":"AutoSymPTRJL(; norm=norm, a=1.0, nmin=50, nmax=1000, n₀=6, Δn=log(10), keepmost=2, nthreads=Threads.nthreads())\n\nPeriodic trapezoidal rule with automatic convergence to tolerances passed to the solver with respect to norm using the routine autosymptr from AutoSymPTR.jl. nthreads sets the numbers of threads used to parallelize the quadrature only when the integrand is a BatchIntegrand, in which case the user must parallelize the integrand evaluations. For no threading set nthreads=1. This algorithm is the most efficient for smooth integrands.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#Meta-algorithms","page":"Algorithms","title":"Meta-algorithms","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"AutoBZCore.NestedQuad\nAutoBZCore.EvalCounter\nAutoBZCore.AbsoluteEstimate","category":"page"},{"location":"algorithms/#AutoBZCore.NestedQuad","page":"Algorithms","title":"AutoBZCore.NestedQuad","text":"NestedQuad(alg::IntegralAlgorithm)\nNestedQuad(algs::IntegralAlgorithm...)\n\nNested integration by repeating one quadrature algorithm or composing a list of algorithms. The domain of integration must be an AbstractIteratedLimits from the IteratedIntegration.jl package. Analogous to nested_quad from IteratedIntegration.jl. The integrand should expect SVector inputs. Do not use this for very high-dimensional integrals, since the compilation time scales very poorly with respect to dimensionality. In order to improve the compilation time, FunctionWrappers.jl is used to enforce type stability of the integrand, so you should always pick the widest integration limit type so that inference works properly. For example, if ContQuadGKJL is used as an algorithm in the nested scheme, then the limits of integration should be made complex.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.EvalCounter","page":"Algorithms","title":"AutoBZCore.EvalCounter","text":"EvalCounter(::IntegralAlgorithm)\n\nAn algorithm which counts the evaluations used by another algorithm. The solution is stored in the sol.u field and the count in the sol.resid field.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.AbsoluteEstimate","page":"Algorithms","title":"AutoBZCore.AbsoluteEstimate","text":"AbsoluteEstimate(est_alg, abs_alg; kws...)\n\nMost algorithms are efficient when using absolute error tolerances, but how do you know the size of the integral? One option is to estimate it using second algorithm.\n\nA multi-algorithm to estimate an integral using an est_alg to generate a rough estimate of the integral that is combined with a user's relative tolerance to re-calculate the integral to higher accuracy using the abs_alg. The keywords passed to the algorithm may include reltol, abstol and maxiters and are given to the est_alg solver. They should limit the amount of work of est_alg so as to only generate an order-of-magnitude estimate of the integral. The tolerances passed to abs_alg are abstol=max(abstol,reltol*norm(I)) and reltol=0.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#BZ-specific","page":"Algorithms","title":"BZ-specific","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"In order to make algorithms domain-agnostic, the BZ loaded from load_bz can be called with the algorithms below, which are wrappers for algorithms above with the additional capability of mapping integrals over the IBZ to the FBZ.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"AutoBZCore.IAI\nAutoBZCore.TAI\nAutoBZCore.PTR\nAutoBZCore.AutoPTR\nAutoBZCore.PTR_IAI\nAutoBZCore.AutoPTR_IAI","category":"page"},{"location":"algorithms/#AutoBZCore.IAI","page":"Algorithms","title":"AutoBZCore.IAI","text":"IAI(alg::IntegralAlgorithm=AuxQuadGKJL())\nIAI(algs::IntegralAlgorithm...)\n\nIterated-adaptive integration using nested_quad from IteratedIntegration.jl. This algorithm is the most efficient for localized integrands.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.TAI","page":"Algorithms","title":"AutoBZCore.TAI","text":"TAI(; norm=norm, initdivs=1)\n\nTree-adaptive integration using hcubature from HCubature.jl. This routine is limited to integration over hypercube domains and may not use all symmetries.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.PTR","page":"Algorithms","title":"AutoBZCore.PTR","text":"PTR(; npt=50, parallel=nothing)\n\nPeriodic trapezoidal rule with a fixed number of k-points per dimension, npt, using the routine ptr from AutoSymPTR.jl. The caller should check that the integral is converged w.r.t. npt.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.AutoPTR","page":"Algorithms","title":"AutoBZCore.AutoPTR","text":"AutoPTR(; norm=norm, a=1.0, nmin=50, nmax=1000, n₀=6, Δn=log(10), keepmost=2, parallel=nothing)\n\nPeriodic trapezoidal rule with automatic convergence to tolerances passed to the solver with respect to norm using the routine autosymptr from AutoSymPTR.jl. This algorithm is the most efficient for smooth integrands.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.PTR_IAI","page":"Algorithms","title":"AutoBZCore.PTR_IAI","text":"PTR_IAI(; ptr=PTR(), iai=IAI())\n\nMulti-algorithm that returns an IAI calculation with an abstol determined from the given reltol and a PTR estimate, I, as reltol*norm(I). This addresses the issue that IAI does not currently use a globally-adaptive algorithm and may not have the expected scaling with localization length unless an abstol is used since computational effort may be wasted via a reltol with the naive nested_quadgk.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#AutoBZCore.AutoPTR_IAI","page":"Algorithms","title":"AutoBZCore.AutoPTR_IAI","text":"AutoPTR_IAI(; reltol=1.0, ptr=AutoPTR(), iai=IAI())\n\nMulti-algorithm that returns an IAI calculation with an abstol determined from an AutoPTR estimate, I, computed to reltol precision, and the rtol given to the solver as abstol=rtol*norm(I). This addresses the issue that IAI does not currently use a globally-adaptive algorithm and may not have the expected scaling with localization length unless an abstol is used since computational effort may be wasted via a reltol with the naive nested_quadgk.\n\n\n\n\n\n","category":"function"}]
}
