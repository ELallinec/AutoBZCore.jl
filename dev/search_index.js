var documenterSearchIndex = {"docs":
[{"location":"extensions/#Package-extensions","page":"Extensions","title":"Package extensions","text":"","category":"section"},{"location":"extensions/#SymmetryReduceBZ.jl","page":"Extensions","title":"SymmetryReduceBZ.jl","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Loading SymmetryReduceBZ.jl provides a specialized method of load_bz that when provided atom species and positions can compute the IBZ.","category":"page"},{"location":"extensions/#WannierIO.jl","page":"Extensions","title":"WannierIO.jl","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Loading WannierIO.jl provides a specialized method of load_bz that loads the BZ defined in a seedname.wout file.","category":"page"},{"location":"extensions/#AtomsBase.jl","page":"Extensions","title":"AtomsBase.jl","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Loading AtomsBase.jl provides a specialized method of load_bz to load the BZ of an AtomsBase.AbstractSystem","category":"page"},{"location":"integrands/#Integrands","page":"Integrands","title":"Integrands","text":"","category":"section"},{"location":"integrands/","page":"Integrands","title":"Integrands","text":"The design of AutoBZCore.jl uses multiple dispatch to provide multiple interfaces for user integrands that allow various optimizations to be compatible with a common interface for solvers.","category":"page"},{"location":"integrands/","page":"Integrands","title":"Integrands","text":"AutoBZCore.IntegralFunction\nAutoBZCore.InplaceIntegralFunction\nAutoBZCore.InplaceBatchIntegralFunction\nAutoBZCore.CommonSolveIntegralFunction\nAutoBZCore.FourierIntegralFunction\nAutoBZCore.CommonSolveFourierIntegralFunction","category":"page"},{"location":"integrands/#AutoBZCore.IntegralFunction","page":"Integrands","title":"AutoBZCore.IntegralFunction","text":"IntegralFunction(f, [prototype=nothing])\n\nConstructor for an out-of-place integrand of the form f(x, p). Optionally, a prototype can be provided for the output of the function.\n\n\n\n\n\n","category":"type"},{"location":"integrands/#AutoBZCore.InplaceIntegralFunction","page":"Integrands","title":"AutoBZCore.InplaceIntegralFunction","text":"InplaceIntegralFunction(f!, prototype::AbstractArray)\n\nConstructor for an inplace integrand of the form f!(y, x, p). A prototype array is required to store the same type and size as the result, y.\n\n\n\n\n\n","category":"type"},{"location":"integrands/#AutoBZCore.InplaceBatchIntegralFunction","page":"Integrands","title":"AutoBZCore.InplaceBatchIntegralFunction","text":"InplaceBatchIntegralFunction(f!, prototype; max_batch::Integer=typemax(Int))\n\nConstructor for an inplace, batched integrand of the form f!(y, x, p) that accepts an array x containing a batch of evaluation points stored along the last axis of the array. A prototype array is required to store the same type and size as the result, y, however the last axis, which is reserved for batching, which should contain at least one element. The max_batch keyword sets a soft limit on the number of points batched simultaneously.\n\n\n\n\n\n","category":"type"},{"location":"integrands/#AutoBZCore.CommonSolveIntegralFunction","page":"Integrands","title":"AutoBZCore.CommonSolveIntegralFunction","text":"CommonSolveIntegralFunction(prob, alg, update!, postsolve, [prototype, specialize]; kws...)\n\nConstructor for an integrand that solves a problem defined with the CommonSolve.jl interface, prob, which is instantiated using init(prob, alg; kws...). Helper functions include: update!(cache, x, p) is called before solve!(cache), followed by postsolve(sol, x, p), which should return the value of the solution. The prototype argument can help control how much to specialize on the type of the problem, which defaults to FullSpecialize() so that run times are improved. However FunctionWrapperSpecialize() may help reduce compile times.\n\n\n\n\n\n","category":"type"},{"location":"integrands/#AutoBZCore.FourierIntegralFunction","page":"Integrands","title":"AutoBZCore.FourierIntegralFunction","text":"FourierIntegralFunction(f, s, [prototype=nothing]; alias=false)\n\nArguments\n\nf: The integrand, accepting inputs f(x, s(x), p)\ns::AbstractFourierSeries: The Fourier series to evaluate\nprototype:\nalias::Bool: whether to deepcopy the series (false) or use the series as-is (true)\n\n\n\n\n\n","category":"type"},{"location":"integrands/#AutoBZCore.CommonSolveFourierIntegralFunction","page":"Integrands","title":"AutoBZCore.CommonSolveFourierIntegralFunction","text":"CommonSolveFourierIntegralFunction(prob, alg, update!, postsolve, s, [prototype, specialize]; alias=false, kws...)\n\nConstructor for an integrand that solves a problem defined with the CommonSolve.jl interface, prob, which is instantiated using init(prob, alg; kws...). Helper functions include: update!(cache, x, s(x), p) is called before solve!(cache), followed by postsolve(sol, x, s(x), p), which should return the value of the solution. The prototype argument can help control how much to specialize on the type of the problem, which defaults to FullSpecialize() so that run times are improved. However FunctionWrapperSpecialize() may help reduce compile times.\n\n\n\n\n\n","category":"type"},{"location":"problems/#Problem-definitions","page":"Problems","title":"Problem definitions","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"The design of AutoBZCore.jl is heavily influenced by SciML packages and uses the  CommonSolve.jl interface. Eventually, this package may contribute to Integrals.jl.","category":"page"},{"location":"problems/#Problem-interface","page":"Problems","title":"Problem interface","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"AutoBZCore.jl replicates the Integrals.jl interface, using an IntegralProblem type to setup an integral from an integrand, a domain, and parameters.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"using AutoBZCore\n\nf = (x,p) -> sin(p*x)\ndom = (0, 1)\np = 0.3\nprob = IntegralProblem(f, dom, p)","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"AutoBZCore.IntegralProblem\nAutoBZCore.NullParameters","category":"page"},{"location":"problems/#AutoBZCore.IntegralProblem","page":"Problems","title":"AutoBZCore.IntegralProblem","text":"IntegralProblem(f, domain, [p=NullParameters]; kwargs...)\n\nArguments\n\nf::AbstractIntegralFunction: The function to integrate\ndomain: The domain to integrate over, e.g. (lb, ub)\np: Parameters to pass to the integrand\n\nKeywords\n\nAdditional keywords are passed directly to the solver\n\n\n\n\n\n","category":"type"},{"location":"problems/#AutoBZCore.NullParameters","page":"Problems","title":"AutoBZCore.NullParameters","text":"NullParameters()\n\nA singleton type representing absent parameters\n\n\n\n\n\n","category":"type"},{"location":"problems/#solve","page":"Problems","title":"solve","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"To solve an integral problem, pick an algorithm and call solve","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"alg = QuadGKJL()\nsolve(prob, alg)","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"AutoBZCore.solve","category":"page"},{"location":"problems/#CommonSolve.solve","page":"Problems","title":"CommonSolve.solve","text":"solve(::IntegralProblem, ::IntegralAlgorithm; kws...)::IntegralSolution\n\nCompute the solution to the given IntegralProblem using the given IntegralAlgorithm for the given keyword arguments to the solver (i.e. abstol, reltol, or maxiters).\n\nKeywords\n\nabstol: an absolute error tolerance to get the solution to a specified number of absolute digits, e.g. 1e-3 requests accuracy to 3 decimal places.  Note that this number must have the same units as the integral. (default: nothing)\nreltol: a relative error tolerance equivalent to specifying a number of significant digits of accuracy, e.g. 1e-4 requests accuracy to roughly 4 significant digits. (default: nothing)\nmaxiters: a soft upper limit on the number of integrand evaluations (default: typemax(Int))\n\nSolvers typically converge only to the weakest error condition. For example, a relative tolerance can be used in combination with a smaller-than necessary absolute tolerance so that the solution is resolved up to the requested significant digits, unless the integral is smaller than the absolute tolerance.\n\n\n\n\n\nsolve(::AutoBZProblem, ::AutoBZAlgorithm; kws...)::IntegralSolution\n\n\n\n\n\nsolve(::DOSProblem, ::DOSAlgorithm; kws...)::DOSSolution\n\n\n\n\n\n","category":"function"},{"location":"problems/#init-and-solve!","page":"Problems","title":"init and solve!","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"To solve many problems with the same integrand but different domains or parameters, use init to allocate a solver and solve! to get the solution","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"solver = init(prob, alg)\nsolve!(solver).value","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"To solve again, update the parameters of the solver in place and solve! again","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"# solve again at a new parameter\nsolver.p = 0.4\nsolve!(solver).value","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"AutoBZCore.init\nAutoBZCore.solve!","category":"page"},{"location":"problems/#CommonSolve.init","page":"Problems","title":"CommonSolve.init","text":"init(::IntegralProblem, ::IntegralAlgorithm; kws...)::IntegralSolver\n\nConstruct a cache for an IntegralProblem, IntegralAlgorithm, and the keyword arguments to the solver (i.e. abstol, reltol, or maxiters) that can be reused for solving the problem for multiple different parameters of the same type.\n\n\n\n\n\ninit(::DOSProblem, ::DOSAlgorithm; kwargs...)::DOSCache\n\nCreate a cache of the data used by an algorithm to solve the given problem.\n\n\n\n\n\n","category":"function"},{"location":"problems/#CommonSolve.solve!","page":"Problems","title":"CommonSolve.solve!","text":"solve!(::IntegralSolver)::IntegralSolution\n\nCompute the solution to an IntegralProblem constructed from init.\n\n\n\n\n\nsolve!(::IntegralCache)::IntegralSolution\n\nCompute the solution to an IntegralProblem constructed from init.\n\n\n\n\n\nsolve!(::DOSCache)::DOSSolution\n\nCompute the solution of a problem from the initialized cache\n\n\n\n\n\n","category":"function"},{"location":"problems/#Additional-problems","page":"Problems","title":"Additional problems","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"AutoBZCore.AutoBZProblem\nAutoBZCore.DOSProblem","category":"page"},{"location":"problems/#AutoBZCore.AutoBZProblem","page":"Problems","title":"AutoBZCore.AutoBZProblem","text":"AutoBZProblem([rep], f, bz, [p]; kwargs...)\n\nConstruct a BZ integration problem.\n\nArguments\n\nrep::AbstractSymRep: The symmetry representation of f (default: UnknownRep())\nf::AbstractIntegralFunction: The integrand\nbz::SymmetricBZ: The Brillouin zone to integrate over\np: parameters for the integrand (default: NullParameters())\n\nKeywords\n\nAdditional keywords are passed directly to the solver\n\n\n\n\n\n","category":"type"},{"location":"problems/#AutoBZCore.DOSProblem","page":"Problems","title":"AutoBZCore.DOSProblem","text":"DOSProblem(H, domain, [p=NullParameters()])\n\nDefine a problem for the density of states of a Hermitian or self-adjoint operator depending on a parameter, H(p), on a given domain in its spectrum. The mathematical definition we use is\n\nD(E) = sum_k in p sum_lambda in textspectrum(H(k)) delta(E - lambda)\n\nwhere E in textdomain and delta is the Dirac Delta distribution.\n\nArguments\n\nH: a linear operator depending on a parameter, H(p), that is finite dimensional (e.g: tight binding model) or infinite dimensional (e.g. DFT data)\ndomain: a set in the spectrum for which an approximation of the density-of-states is desired. Can be a single point, in which case the solution will return the estimated density of states at that eigenvalue, or an interval, in which case the solution will return a function approximation to the density of states on that interval in the spectrum that should be understood as a distribution or measure.\np: optional parameters on which H depends for which the density of states should sum over. Can be discrete (e.g. for H a Hamiltonian with spin degrees of freedom) or continuous (e.g. for H a Hamiltonian parameterized by crystal momentum).\n\n\n\n\n\n","category":"type"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following are several examples of how to use the algorithms and integrands provided by AutoBZCore.jl. For background on the essential interface see the Problem definitions page","category":"page"},{"location":"examples/#Green's-function-integration","page":"Examples","title":"Green's function integration","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"A common integral appearing in Dynamical mean-field theory is that of the local Green's function:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"G(omega) = int d^d veck operatornameTr left left( omega - H left( veck right) - Sigma(omega) right)^-1 right","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For simplicity, we take Sigma(omega) = -ieta. We can define the integrand as a function of veck and H and parameters eta omega.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using LinearAlgebra\ngloc_integrand(k, (; h, η, ω)) = tr(inv(complex(ω,η)*I-h(k)))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we use named tuple destructuring syntax to unpack a named tuple of parameters in the function definition.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Commonly, H(veck) is evaluated using Wannier interpolation, i.e. as a Fourier series. For a simple tight-binding model, the integer lattice, the Hamiltonian is given by","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"H(k) = cos(2pi k) = frac12 left( e^2pi ik + e^-2pi ik right)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can use the built-in function cos to evaluate this, however, for more complex Fourier series it becomes easier to use the representation in terms of Fourier coefficients. Using the package FourierSeriesEvaluators.jl, we can define H(k) = cos(2pi k) by the following:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using FourierSeriesEvaluators\nh = FourierSeries([0.5, 0.0, 0.5]; period=1, offset=-2)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The coefficient values of 12 can be determined from Euler's formula, as used in the expansion of cos above, and the value of offset is chosen to offset the coefficient array indices, 1:3 since Julia has 1-based indexing, to correspond to values of n in the phase factors e^2pi i n k used in the Fourier series above, i.e. -1:1. Now we proceed to the define the IntegralProblem and solve it with a generic adaptive integration scheme, QuadGKJL","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AutoBZCore\ndom = (0, 1)\np = (; h, η=0.1, ω=0.0)\nprob = IntegralProblem(gloc_integrand, dom, p)\nalg = QuadGKJL()\nsolve(prob, alg; abstol=1e-3).value","category":"page"},{"location":"examples/#BZ-integration","page":"Examples","title":"BZ integration","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"To perform integration over a Brillouin zone, we can load one using the load_bz function and then construct an AutoBZProblem to solve. Since the Brillouin zone may be reduced using point group symmetries, a common optimization, it is also required to specify the symmetry representation of the integrand. Continuing the previous example, the trace of the Green's function has no band/orbital degrees of freedom and transforms trivially under the point group, so it is a TrivialRep. The previous calculation can be replicated as:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AutoBZCore\nbz = load_bz(FBZ(), 2pi*I(1))\np = (; h, η=0.1, ω=0.0)\nprob = AutoBZProblem(TrivialRep(), IntegralFunction(gloc_integrand), bz, p)\nalg = TAI()\nsolve(prob, alg; abstol=1e-3).value","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we proceed to multi-dimensional integrals. In this case, Wannier interpolation is much more efficient when Fourier series are evaluated one variable at a time. To understand, this suppose we have a series defined by M times M coefficients (i.e. a 2d series) that we want to evaluate on an N times N grid. Naively evaluating the series at each grid point will require mathcalO(M^2 N^2) operations, however, we can reduce the complexity by pre-evaluating certain coefficients as follows","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"f(x y) = sum_mn=1^M f_nm e^i(nx + my) = sum_n=1^M e^inx left( sum_m=1^M f_nm e^imy right) = sum_n=1^M e^inx tildef_n(y)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This means we can evaluate the series on the grid in mathcalO(M N^2 + M^2 N) operations. When N gg M, this is mathcalO(M N^2) operations, which is comparable to the computational complexity of a multi-dimensional FFT. Since the constants of a FFT may not be trivial, this scheme is competitive.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let's use this with a Fourier series corresponding to H(veck) = cos(2pi k_x) + cos(2pi k_y) and define a new method of gloc_integrand that accepts the (efficiently) evaluated Fourier series in the second argument","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"h = FourierSeries([0.0; 0.5; 0.0;; 0.5; 0.0; 0.5;; 0.0; 0.5; 0.0]; period=1, offset=-2)\ngloc_integrand(k, h_k, (; η, ω)) = tr(inv(complex(ω,η)*I-h_k))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Similar to before, we construct an AutoBZCore.IntegralProblem and this time we take the integration domain to correspond to the full Brillouin zone of a square lattice with lattice vectors 2pi*I(2).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"integrand = FourierIntegralFunction(gloc_integrand, h)\nbz = load_bz(FBZ(2), 2pi*I(2))\np = (; η=0.1, ω=0.0)\nprob = AutoBZProblem(TrivialRep(), integrand, bz, p)\nalg = IAI()\nsolve(prob, alg).value","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This package provides several AutoBZProblem algorithms that we can use to solve the multidimensional integral.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The repo's demo on density of states provides a complete example of how to compute and interpolate an integral as a function of its parameters using the init and solve! interface","category":"page"},{"location":"examples/#Density-of-States","page":"Examples","title":"Density of States","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Computing the density of states (DOS) of a self-adjoint, or Hermitian, operator is a related, but distinct problem to the integrals also presented in this package. In fact, many DOS algorithms will compute integrals to approximate the DOS of an operator by introducing an artificial broadening. To handle the T=0^+ limit of the broadening, we implement the well-known Gilat-Raubenheimer method as an algorithm for the AutoBZCore.DOSProblem","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Using the AutoBZCore.init and AutoBZCore.solve! functions, it is possible to construct a cache to solve a DOSProblem for several energies or several Hamiltonians. As an example of solving for several energies,","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AutoBZCore, FourierSeriesEvaluators, StaticArrays\nh = FourierSeries(SMatrix{1,1,Float64,1}.([0.5, 0.0, 0.5]), period=1.0, offset=-2)\nE = 0.3\nbz = load_bz(FBZ(), [2pi;;])\nprob = DOSProblem(h, E, bz)\nalg = GGR(; npt=100)\ncache = init(prob, alg)\nEs = range(-1, 1, length=10) * 1.1\ndata = map(Es) do E\n    cache.domain = E\n    solve!(cache).value\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"As an example of interchanging Hamiltonians, which must remain the same type, we can double the energies, which will halve the DOS","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"cache.domain = E\nsol1 = AutoBZCore.solve!(cache)\n\nh.c .*= 2\ncache.isfresh = true\ncache.domain = 2E\n\nsol2 = AutoBZCore.solve!(cache)\n\nsol1.value ≈ 2sol2.value","category":"page"},{"location":"reference/#Function-reference","page":"Reference","title":"Function reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The following symbols are exported by AutoBZCore.jl","category":"page"},{"location":"reference/#Brillouin-zone-kinds","page":"Reference","title":"Brillouin-zone kinds","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"AutoBZCore.load_bz\nAutoBZCore.load_bz(::IBZ, A, B, species, positions)\nAutoBZCore.AbstractBZ\nAutoBZCore.FBZ\nAutoBZCore.IBZ\nAutoBZCore.InversionSymIBZ\nAutoBZCore.CubicSymIBZ","category":"page"},{"location":"reference/#AutoBZCore.load_bz","page":"Reference","title":"AutoBZCore.load_bz","text":"load_bz(bz::AbstractBZ, [T::Type=Float64])\nload_bz(bz::AbstractBZ, A::AbstractMatrix, [B::AbstractMatrix])\n\nInterface to loading Brillouin zones.\n\nArguments\n\nbz::AbstractBZ: a kind of Brillouin zone to construct, e.g. FBZ or IBZ\nT::Type: a numeric type to set the precision of the domain (default: Float64)\nA::AbstractMatrix: a d times d matrix whose columns are the real-space lattice vectors of a d-dimensional crystal\nB::AbstractMatrix: a d times d matrix whose columns are the reciprocal-space lattice vectors of a d-dimensional Brillouin zone (default: A' \\ 2πI)\n\nnote: Assumptions\nAutoBZCore assumes that all calculations occur in the reciprocal lattice basis, since that is the basis in which Wannier interpolants are most efficiently described. See SymmetricBZ for details. We also assume that the integrands are cheap to evaluate, which is why we provide adaptive methods in the first place, so that return types can be determined at runtime (and mechanisms are in place for compile time as well)\n\n\n\n\n\n","category":"function"},{"location":"reference/#AutoBZCore.load_bz-Tuple{IBZ, Vararg{Any, 4}}","page":"Reference","title":"AutoBZCore.load_bz","text":"load_bz(::IBZ, A, B, species::AbstractVector, positions::AbstractMatrix; kws...)\n\nspecies must have distinct labels for each atom type (e.g. can be any string or integer) and positions must be a matrix whose columns give the coordinates of the atom of the corresponding species.\n\n\n\n\n\n","category":"method"},{"location":"reference/#AutoBZCore.AbstractBZ","page":"Reference","title":"AutoBZCore.AbstractBZ","text":"AbstractBZ{d}\n\nAbstract supertype for all Brillouin zone data types parametrized by dimension.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.FBZ","page":"Reference","title":"AutoBZCore.FBZ","text":"FBZ{N} <: AbstractBZ\n\nSingleton type representing first/full Brillouin zones of N dimensions. By default, N is nothing and the dimension is obtained from input files.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.IBZ","page":"Reference","title":"AutoBZCore.IBZ","text":"IBZ <: AbstractBZ\n\nSingleton type representing irreducible Brillouin zones. Load SymmetryReduceBZ.jl to use this.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.InversionSymIBZ","page":"Reference","title":"AutoBZCore.InversionSymIBZ","text":"InversionSymIBZ{N} <: AbstractBZ\n\nSingleton type representing Brillouin zones with full inversion symmetry\n\nwarning: Assumptions\nOnly expect this to work for systems with orthogonal lattice vectors\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.CubicSymIBZ","page":"Reference","title":"AutoBZCore.CubicSymIBZ","text":"CubicSymIBZ{N} <: AbstractBZ\n\nSingleton type representing Brillouin zones with full cubic symmetry\n\nwarning: Assumptions\nOnly expect this to work for systems with orthogonal lattice vectors\n\n\n\n\n\n","category":"type"},{"location":"reference/#Symmetry-representations","page":"Reference","title":"Symmetry representations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"AutoBZCore.AbstractSymRep\nAutoBZCore.TrivialRep\nAutoBZCore.UnknownRep\nAutoBZCore.symmetrize","category":"page"},{"location":"reference/#AutoBZCore.AbstractSymRep","page":"Reference","title":"AutoBZCore.AbstractSymRep","text":"AbstractSymRep\n\nAbstract supertype of symmetry representation traits.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.TrivialRep","page":"Reference","title":"AutoBZCore.TrivialRep","text":"TrivialRep()\n\nSymmetry representation of objects with trivial transformation under the group.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.UnknownRep","page":"Reference","title":"AutoBZCore.UnknownRep","text":"UnknownRep()\n\nFallback symmetry representation for array types without a user-defined SymRep. Will perform FBZ integration regardless of available BZ symmetries.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.symmetrize","page":"Reference","title":"AutoBZCore.symmetrize","text":"symmetrize(rep::AbstractSymRep, ::SymmetricBZ, x)\n\nTransform x by the representation of the symmetries of the point group used to reduce the domain, thus mapping the value of x on to the full Brillouin zone.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Internal","page":"Reference","title":"Internal","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The following docstrings belong to internal types and functions that may change between versions of AutoBZCore.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"AutoBZCore.PuncturedInterval\nAutoBZCore.HyperCube\nAutoBZCore.SymmetricBZ\nAutoBZCore.trapz\nAutoBZCore.cube_automorphisms","category":"page"},{"location":"reference/#AutoBZCore.PuncturedInterval","page":"Reference","title":"AutoBZCore.PuncturedInterval","text":"PuncturedInterval(s)\n\nRepresent an interval (a, b) with interior points deleted by s = (a, c1, ..., cN, b), so that the integration algorithm can avoid the points c1, ..., cN for e.g. discontinuities. s must be a tuple or vector.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.HyperCube","page":"Reference","title":"AutoBZCore.HyperCube","text":"HyperCube(a, b)\n\nRepresents a hypercube spanned by the vertices a, b, which must be iterables of the same length.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.SymmetricBZ","page":"Reference","title":"AutoBZCore.SymmetricBZ","text":"SymmetricBZ(A, B, lims::AbstractIteratedLimits, syms; atol=sqrt(eps()))\n\nData type representing a Brillouin zone reduced by a set of symmetries, syms with iterated integration limits lims, both of which are assumed to be in the lattice basis (since the Fourier series is). A and B should be identically-sized square matrices containing the real and reciprocal basis vectors in their columns.\n\nnote: Convention\nThis type assumes all integration limit data is in the reciprocal lattice basis with fractional coordinates, where the FBZ is just the hypercube spanned by the vertices (0,…,0) & (1,…,1). If necessary, use A or B to rotate these quantities into the convention.\n\nlims should be limits compatible with IteratedIntegration.jl. syms should be an iterable collection of point group symmetries compatible with AutoSymPTR.jl.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.trapz","page":"Reference","title":"AutoBZCore.trapz","text":"trapz(n::Integer)\n\nReturn the weights and nodes on the standard interval [-1,1] of the trapezoidal rule.\n\n\n\n\n\n","category":"function"},{"location":"reference/#AutoBZCore.cube_automorphisms","page":"Reference","title":"AutoBZCore.cube_automorphisms","text":"cube_automorphisms(::Val{d}) where d\n\nreturn a generator of the symmetries of the cube in d dimensions including the identity.\n\n\n\n\n\n","category":"function"},{"location":"#AutoBZCore.jl","page":"Home","title":"AutoBZCore.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AutoBZCore","category":"page"},{"location":"#AutoBZCore","page":"Home","title":"AutoBZCore","text":"A package providing a common interface to integration algorithms intended for applications including Brillouin-zone integration and Wannier interpolation. Its design is influenced by high-level libraries like Integrals.jl to implement the CommonSolve.jl interface, and it makes use of Julia's multiple dispatch to provide the same interface for integrands with optimized inplace, batched, and Fourier series evaluation.\n\nQuickstart\n\nAs a first example, we integrate sine over [0,1] as a function of its period.\n\njulia> using AutoBZCore\n\njulia> prob = IntegralProblem((x,p) -> sin(p*x), (0, 1), 0.3);\n\njulia> solve(prob, QuadGKJL()).value # solves the integral of sin(p*x) over [0,1] with p=0.3\n0.14887836958131329\n\nNotice that we construct an IntegralProblem object that we can solve at with a choice of algorithm. For more examples, see the documentation.\n\nFeatures\n\nSpecial integrand interfaces\n\nIntegralFunction: generic user integrand of the form f(x, p)\nInplaceIntegralFunction: allows an integrand to write its result inplace to an array\nInplaceBatchIntegralFunction: allows user-side parallelization on e.g. shared memory, distributed memory, or the gpu\nCommonSolveIntegralFunction: define an integrand that also solves a problem\nFourierIntegralFunction: efficient evaluation of Fourier series for cubatures with hierachical grids\n\nQuadrature algorithms:\n\nTrapezoidal rule and FastGaussQuadrature.jl: QuadratureFunction\nh-adaptive quadrature (Gauss-Kronrod): QuadGKJL\nh-adaptive cubature (Genz-Malik): HCubatureJL\np-adaptive, symmetrized Monkhorst-Pack: AutoSymPTRJL\n\nMeta-Algorithms:\n\nIterated integration: NestedQuad\n\nExtended help\n\nIf you experience issues with AutoBZCore.jl, please report a bug on the GitHub page to contact the developers.\n\n\n\n\n\n","category":"module"},{"location":"algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"algorithms/#IntegralProblem-algorithms","page":"Algorithms","title":"IntegralProblem algorithms","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"AutoBZCore.IntegralAlgorithm","category":"page"},{"location":"algorithms/#AutoBZCore.IntegralAlgorithm","page":"Algorithms","title":"AutoBZCore.IntegralAlgorithm","text":"IntegralAlgorithm\n\nAbstract supertype for integration algorithms.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#Quadrature","page":"Algorithms","title":"Quadrature","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"AutoBZCore.QuadratureFunction\nAutoBZCore.QuadGKJL\nAutoBZCore.AuxQuadGKJL\nAutoBZCore.ContQuadGKJL\nAutoBZCore.MeroQuadGKJL","category":"page"},{"location":"algorithms/#AutoBZCore.QuadratureFunction","page":"Algorithms","title":"AutoBZCore.QuadratureFunction","text":"QuadratureFunction(; fun=trapz, npt=50, nthreads=1)\n\nQuadrature rule for the standard interval [-1,1] computed from a function x, w = fun(npt). The nodes and weights should be set so the integral of f on [-1,1] is sum(w .* f.(x)). The default quadrature rule is trapz, although other packages provide rules, e.g.\n\nusing FastGaussQuadrature\nalg = QuadratureFunction(fun=gausslegendre, npt=100)\n\nnthreads sets the numbers of threads used to parallelize the quadrature only when the integrand is a , in which case the user must parallelize the integrand evaluations. For no threading set nthreads=1.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.QuadGKJL","page":"Algorithms","title":"AutoBZCore.QuadGKJL","text":"QuadGKJL(; order = 7, norm = norm)\n\nDuplicate of the QuadGKJL provided by Integrals.jl.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.AuxQuadGKJL","page":"Algorithms","title":"AutoBZCore.AuxQuadGKJL","text":"AuxQuadGKJL(; order = 7, norm = norm)\n\nGeneralization of the QuadGKJL provided by Integrals.jl that allows for AuxValued integrands for auxiliary integration and multi-threaded evaluation with the batch argument to IntegralProblem\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.ContQuadGKJL","page":"Algorithms","title":"AutoBZCore.ContQuadGKJL","text":"ContQuadGKJL(; order = 7, norm = norm, rho = 1.0, rootmeth = IteratedIntegration.ContQuadGK.NewtonDeflation())\n\nA 1d contour deformation quadrature scheme for scalar, complex-valued integrands. It defaults to regular quadgk behavior on the real axis, but if it finds a root of 1/f nearby, in the sense of Bernstein ellipse for the standard segment [-1,1] with semiaxes cosh(rho) and sinh(rho), on either the upper/lower half planes, then it dents the contour away from the presumable pole.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.MeroQuadGKJL","page":"Algorithms","title":"AutoBZCore.MeroQuadGKJL","text":"MeroQuadGKJL(; order = 7, norm = norm, rho = 1.0, rootmeth = IteratedIntegration.MeroQuadGK.NewtonDeflation())\n\nA 1d pole subtraction quadrature scheme for scalar, complex-valued integrands that are meromorphic. It defaults to regular quadgk behavior on the real axis, but if it finds nearby roots of 1/f, in the sense of Bernstein ellipse for the standard segment [-1,1] with semiaxes cosh(rho) and sinh(rho), it attempts pole subtraction on that segment.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#Cubature","page":"Algorithms","title":"Cubature","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"AutoBZCore.HCubatureJL\nAutoBZCore.MonkhorstPack\nAutoBZCore.AutoSymPTRJL","category":"page"},{"location":"algorithms/#AutoBZCore.HCubatureJL","page":"Algorithms","title":"AutoBZCore.HCubatureJL","text":"HCubatureJL(; norm=norm, initdiv=1)\n\nMulti-dimensional h-adaptive cubature from HCubature.jl.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.MonkhorstPack","page":"Algorithms","title":"AutoBZCore.MonkhorstPack","text":"MonkhorstPack(; npt=50, syms=nothing, nthreads=1)\n\nPeriodic trapezoidal rule with a fixed number of k-points per dimension, npt, using the PTR rule from AutoSymPTR.jl. nthreads sets the numbers of threads used to parallelize the quadrature only when the integrand is a , in which case the user must parallelize the integrand evaluations. For no threading set nthreads=1. The caller should check that the integral is converged w.r.t. npt.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.AutoSymPTRJL","page":"Algorithms","title":"AutoBZCore.AutoSymPTRJL","text":"AutoSymPTRJL(; norm=norm, a=1.0, nmin=50, nmax=1000, n₀=6, Δn=log(10), keepmost=2, nthreads=1)\n\nPeriodic trapezoidal rule with automatic convergence to tolerances passed to the solver with respect to norm using the routine autosymptr from AutoSymPTR.jl. nthreads sets the numbers of threads used to parallelize the quadrature only when the integrand is a  in which case the user must parallelize the integrand evaluations. For no threading set nthreads=1. This algorithm is the most efficient for smooth integrands.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#Meta-algorithms","page":"Algorithms","title":"Meta-algorithms","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"AutoBZCore.NestedQuad","category":"page"},{"location":"algorithms/#AutoBZCore.NestedQuad","page":"Algorithms","title":"AutoBZCore.NestedQuad","text":"NestedQuad(alg::IntegralAlgorithm)\nNestedQuad(algs::IntegralAlgorithm...)\n\nNested integration by repeating one quadrature algorithm or composing a list of algorithms. The domain of integration must be an AbstractIteratedLimits from the IteratedIntegration.jl package. Analogous to nested_quad from IteratedIntegration.jl. The integrand should expect SVector inputs. Do not use this for very high-dimensional integrals, since the compilation time scales very poorly with respect to dimensionality. In order to improve the compilation time, FunctionWrappers.jl is used to enforce type stability of the integrand, so you should always pick the widest integration limit type so that inference works properly. For example, if ContQuadGKJL is used as an algorithm in the nested scheme, then the limits of integration should be made complex.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZProblem-algorithms","page":"Algorithms","title":"AutoBZProblem algorithms","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"In order to make algorithms domain-agnostic, the BZ loaded from load_bz can be called with the algorithms below, which are aliases for algorithms above","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"AutoBZCore.AutoBZAlgorithm\nAutoBZCore.IAI\nAutoBZCore.TAI\nAutoBZCore.PTR\nAutoBZCore.AutoPTR","category":"page"},{"location":"algorithms/#AutoBZCore.AutoBZAlgorithm","page":"Algorithms","title":"AutoBZCore.AutoBZAlgorithm","text":"AutoBZAlgorithm\n\nAbstract supertype for Brillouin zone integration algorithms. All integration problems on the BZ get rescaled to fractional coordinates so that the Brillouin zone becomes [0,1]^d, and integrands should have this periodicity. If the integrand depends on the Brillouin zone basis, then it may have to be transformed to the Cartesian coordinates as a post-processing step. These algorithms also use the symmetries of the Brillouin zone and the integrand.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.IAI","page":"Algorithms","title":"AutoBZCore.IAI","text":"IAI(alg::IntegralAlgorithm=AuxQuadGKJL())\nIAI(algs::IntegralAlgorithm...)\n\nIterated-adaptive integration using nested_quad from IteratedIntegration.jl. This algorithm is the most efficient for localized integrands.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.TAI","page":"Algorithms","title":"AutoBZCore.TAI","text":"TAI(; norm=norm, initdivs=1)\n\nTree-adaptive integration using hcubature from HCubature.jl. This routine is limited to integration over hypercube domains and may not use all symmetries.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.PTR","page":"Algorithms","title":"AutoBZCore.PTR","text":"PTR(; npt=50, nthreads=1)\n\nPeriodic trapezoidal rule with a fixed number of k-points per dimension, npt, using the routine ptr from AutoSymPTR.jl. The caller should check that the integral is converged w.r.t. npt.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.AutoPTR","page":"Algorithms","title":"AutoBZCore.AutoPTR","text":"AutoPTR(; norm=norm, a=1.0, nmin=50, nmax=1000, n₀=6, Δn=log(10), keepmost=2, nthreads=1)\n\nPeriodic trapezoidal rule with automatic convergence to tolerances passed to the solver with respect to norm using the routine autosymptr from AutoSymPTR.jl. This algorithm is the most efficient for smooth integrands.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#DOSProblem-algorithms","page":"Algorithms","title":"DOSProblem algorithms","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Currently the available algorithms are an initial release and we would like to include the following reference algorithms that are also common in the literature in a future release:","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"(Linear) Tetrahedron Method\nAdaptive Gaussian broadening","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"AutoBZCore.DOSAlgorithm\nAutoBZCore.GGR","category":"page"},{"location":"algorithms/#AutoBZCore.DOSAlgorithm","page":"Algorithms","title":"AutoBZCore.DOSAlgorithm","text":"DOSAlgorithm\n\nAbstract supertype for algorithms for computing density of states\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.GGR","page":"Algorithms","title":"AutoBZCore.GGR","text":"GGR(; npt=50)\n\nGeneralized Gilat-Raubenheimer method as in \"Generalized Gilat–Raubenheimer method for density-of-states calculation in photonic crystals\". This method requires the Hamiltonian and its derivatives, and performs a linear extrapolation at each k-point in an equispace grid. The algorithm is expected to show second-order convergence and suffer reduced error at band crossings compared to interpolatory methods.\n\nArguments\n\nnpt: the number of k-points per dimension\n\n\n\n\n\n","category":"type"}]
}
