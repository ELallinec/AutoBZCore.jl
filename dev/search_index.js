var documenterSearchIndex = {"docs":
[{"location":"methods/#Reference","page":"Manual","title":"Reference","text":"","category":"section"},{"location":"methods/","page":"Manual","title":"Manual","text":"Modules = [AutoBZCore]\nOrder   = [:type, :function]","category":"page"},{"location":"methods/#AutoBZCore.FourierIntegrand","page":"Manual","title":"AutoBZCore.FourierIntegrand","text":"FourierIntegrand(f, s::AbstractFourierSeries, p...)\n\nA type generically representing an integrand f whose entire dependence on the variables of integration is in a Fourier series s, and which may also accept some input parameters p. The caller must know that their function, f, will be evaluated at many points, x, in the following way: f(s(x), p...). Therefore the caller is expected to know the type of s(x) (hint: eltype(s)) and the layout of the parameters in the tuple p (hint: it should correspond to the arguments of the function). This type is optimized for the IAI and PTR routines.\n\n\n\n\n\n","category":"type"},{"location":"methods/#AutoBZCore.SymmetricBZ","page":"Manual","title":"AutoBZCore.SymmetricBZ","text":"SymmetricBZ(A, B, lims::AbstractLimits, syms; atol=sqrt(eps()))\n\nData type representing a Brillouin zone reduced by a set of symmetries, syms with iterated integration limits lims, both of which are assumed to be in the lattice basis (since the Fourier series is). A and B should be identically-sized square matrices containing the real and reciprocal basis vectors in their columns. lims should be limits compatible with the IteratedIntegration package that represent the BZ in fractional lattice coordinates (e.g. the full BZ with vertices (0,0,0) & (1,1,1)). syms should be a collection of symmetries compatible with AutoSymPTR and the symmetry operators should be in the lattice basis (if necessary, rotate them from the Cartesian basis).\n\n\n\n\n\n","category":"type"},{"location":"methods/#AutoBZCore.FullBZ","page":"Manual","title":"AutoBZCore.FullBZ","text":"FullBZ(A, B=canonical_reciprocal_basis(A), lims=lattice_bz_limits(B); atol=sqrt(eps()))\n\nA type alias for SymmetricBZ{Nothing} when there are no symmetries applied to BZ\n\n\n\n\n\n","category":"function"},{"location":"methods/#AutoBZCore.batchparam-Tuple{Any, Any}","page":"Manual","title":"AutoBZCore.batchparam","text":"batchparam(xs, nthreads)\n\nIf the cost of a calculation smoothly varies with the parameters xs, then batch xs into nthreads groups where the ith element of group j is xs[j+(i-1)*nthreads]\n\n\n\n\n\n","category":"method"},{"location":"methods/#AutoBZCore.batchsolve","page":"Manual","title":"AutoBZCore.batchsolve","text":"batchsolve(f, ps, [T=Base.promote_op(f, eltype(ps))]; nthreads=Threads.nthreads())\n\nEvaluate the IntegralSolver f at each of the parameters ps in parallel. Returns a vector containing the evaluated integrals I. This is a form of multithreaded broadcasting.\n\n\n\n\n\n","category":"function"},{"location":"methods/#AutoBZCore.symmetrize-Tuple{Any, SymmetricBZ, Vararg{Any, N} where N}","page":"Manual","title":"AutoBZCore.symmetrize","text":"symmetrize(f, ::SymmetricBZ, xs...)\nsymmetrize(f, ::SymmetricBZ, x::Number)\n\nTranform x by the symmetries of the parametrization used to reduce the domain, thus mapping the value of x on the parametrization to the full domain.\n\n\n\n\n\n","category":"method"},{"location":"#AutoBZCore.jl","page":"Home","title":"AutoBZCore.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AutoBZCore","category":"page"},{"location":"#AutoBZCore","page":"Home","title":"AutoBZCore","text":"The package providing the functionality and abstractions for AutoBZ.jl. It provides both SymmetricBZ, which is a type that stores information about the Brillouin zone (BZ), and FourierIntegrator, a type that provides a functor interface to compute user-defined Brillouin zone integrals depending on Wannier-interpolated quantities. The package integrates with FourierSeriesEvaluators, IteratedIntegration, and AutoSymPTR to provide a generic interface to efficient algorithms for BZ integration.\n\nFor example, computing the local Green's function can be done as follows:\n\nusing LinearAlgebra\nusing FourierSeriesEvaluators\nusing AutoBZCore\n\ngloc_integrand(H, η, ω) = inv(complex(ω,η)*I-H) # define integrand evaluator\nh = FourierSeries([0.5, 0.0, 0.5]; offset=-2) # define 1D integer lattice Hamiltonian\nfbz = FullBZ(I(1)) # construct BZ from lattice with default limits of integration\nps = (1.0, 0.0) # representative values for (η,ω), the last arguments of the integrand evaluator\ngloc = FourierIntegrator(gloc_integrand, fbz, h; ps=ps) # initialize default integration routine\ngloc(ps...) # evaluate gloc at parameter points\n\nnote: Assumptions\nAutoBZCore assumes that all calculations occur in the reciprocal lattice basis, since that is the basis in which Wannier interpolants are most efficiently described. This means that user-provided integration limits and symmetries should be in the reciprocal lattice basis and additionally they should be in fractional coordinates (e.g. the BZ in these coordinates has vertices (0,0,0) and (1,1,1)). All symmetry transformations must be dealt with by the user, who can specialize the symmetrize routine to automate that step.\n\n\n\n\n\n","category":"module"}]
}
