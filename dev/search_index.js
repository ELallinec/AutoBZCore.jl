var documenterSearchIndex = {"docs":
[{"location":"integration/#Integration","page":"Integration","title":"Integration","text":"","category":"section"},{"location":"integration/","page":"Integration","title":"Integration","text":"The integration tools provided by AutoBZCore.jl are very flexible and allow for many kinds of user-defined integrals with specialized behaviors. Examples implementations can be found in AutoBZ.jl.","category":"page"},{"location":"integration/#Parametrizing-integrals","page":"Integration","title":"Parametrizing integrals","text":"","category":"section"},{"location":"integration/","page":"Integration","title":"Integration","text":"Integrals.jl provides a generic and unified interface for computing integrals that works well for all kinds of problems. This package builds on that interface by offering IntegralSolvers to easily parametrize an integral for a given integrand, limits of integration, algorithm, and error tolerances. Until the SciML community arrives at a consensus of what a parametrization interface looks like, this gets the job done.","category":"page"},{"location":"integration/","page":"Integration","title":"Integration","text":"IntegralSolver","category":"page"},{"location":"integration/#AutoBZCore.IntegralSolver","page":"Integration","title":"AutoBZCore.IntegralSolver","text":"IntegralSolver(f, lb, ub, alg; abstol=0, reltol=sqrt(eps()), maxiters=typemax(Int))\nIntegralSolver(f, bz::SymmetricBZ, alg::AbstractAutoBZAlgorithm; kwargs...)\n\nConstructs a functor that solves an integral of f over the given domain (e.g. lb to ub or a bz) using the given alg to within the given tolerances. Calling this functor, fun with parameters p using the syntax fun(p) returns the estimated integral I. Under the hood, this uses the Integrals.jl interface for defining an IntegralProblem, so f must be a 2-argument function f(x,p), or if in-place, a 3-argument function f(y,x,p).\n\nAlso, the types Integrand and FourierIntegrand allow for providing a partial set of parameters so that the IntegralSolver can interface easily with other algorithms, such as root-finding and interpolation.\n\n\n\n\n\n","category":"type"},{"location":"integration/#Integrands","page":"Integration","title":"Integrands","text":"","category":"section"},{"location":"integration/","page":"Integration","title":"Integration","text":"User-defined integrands should be able to take any number of parameters and should be entirely general. We only require that the integrand functions take only positional arguments.","category":"page"},{"location":"integration/","page":"Integration","title":"Integration","text":"The integrand types below solve the problem of providing the integrand evaluator parameters a partial set of parameters so that the IntegralSolver can parametrize the remaining ones. Namely, the full set of parameters is the union of the ones included in the integrand follow by those passed to the solver, therefore the caller is responsible for ensuring that the ordered union of parameters they pass to the integrand and solver matches the positional arguments of their integrand evaluator. Note that this behavior slightly differs from using the SciML routine remake for an IntegralProblem.","category":"page"},{"location":"integration/","page":"Integration","title":"Integration","text":"Integrand\nFourierIntegrand","category":"page"},{"location":"integration/#AutoBZCore.Integrand","page":"Integration","title":"AutoBZCore.Integrand","text":"Integrand(f, args...; kwargs...)\n\nRepresent an integrand with a partial collection of parameters p. When the Integrand is invoked with one argument, e.g. int(x), it evaluates f(x, p...; kwargs...). However when invoked with two arguments, as in an IntegralProblem, e.g. int(x, p2), it evaluates the union of parameters f(x, p..., p2...; kwargs...). This allows for convenient parametrization of the integrand.\n\n\n\n\n\n","category":"type"},{"location":"integration/#AutoBZCore.FourierIntegrand","page":"Integration","title":"AutoBZCore.FourierIntegrand","text":"FourierIntegrand(f, s::AbstractFourierSeries, args...; kwargs...)\n\nA type generically representing an integrand f whose entire dependence on the variables of integration is in a Fourier series s, and which may also accept some input parameters p. The caller must know that their function, f, will be evaluated at many points, x, in the following way: f(s(x), p...). Therefore the caller is expected to know the type of s(x) and the layout of the parameters in the tuple p (hint: it should correspond to the arguments of the function). This type is optimized for the IAI and PTR routines.\n\n\n\n\n\n","category":"type"},{"location":"integration/#Algorithms","page":"Integration","title":"Algorithms","text":"","category":"section"},{"location":"integration/","page":"Integration","title":"Integration","text":"There are many Brillouin zone integration algorithms, but the ones provided by this package work for black-box integrands and converge automatically to a requested tolerance, except where noted. Additionally, the algorithms are fully compatible with integration over the IBZ, except where noted. More details on the algorithms can be found from their respective packages.","category":"page"},{"location":"integration/","page":"Integration","title":"Integration","text":"AbstractAutoBZAlgorithm\nIAI\nPTR\nAutoPTR\nPTR_IAI\nAutoPTR_IAI\nTAI","category":"page"},{"location":"integration/#AutoBZCore.AbstractAutoBZAlgorithm","page":"Integration","title":"AutoBZCore.AbstractAutoBZAlgorithm","text":"AbstractAutoBZAlgorithm\n\nAbstract supertype for Brillouin zone integration algorithms.\n\n\n\n\n\n","category":"type"},{"location":"integration/#AutoBZCore.IAI","page":"Integration","title":"AutoBZCore.IAI","text":"IAI(; order=7, norm=norm, initdivs=nothing, segbufs=nothing)\n\nIterated-adaptive integration using nested_quadgk from IteratedIntegration.jl. This algorithm is the most efficient for localized integrands. See alloc_segbufs for how to pre-allocate segment buffers for nested_quadgk.\n\n\n\n\n\n","category":"type"},{"location":"integration/#AutoBZCore.PTR","page":"Integration","title":"AutoBZCore.PTR","text":"PTR(; npt=50, rule=nothing)\n\nPeriodic trapezoidal rule with a fixed number of k-points per dimension, npt, using the routine ptr from AutoSymPTR.jl. The caller should check that the integral is converged w.r.t. npt. See alloc_rule for how to pre-evaluate a PTR rule for use across calls with compatible integrands.\n\n\n\n\n\n","category":"type"},{"location":"integration/#AutoBZCore.AutoPTR","page":"Integration","title":"AutoBZCore.AutoPTR","text":"AutoPTR(; norm=norm, buffer=nothing)\n\nPeriodic trapezoidal rule with automatic convergence to tolerances passed to the solver with respect to norm using the routine autosymptr from AutoSymPTR.jl. This algorithm is the most efficient for smooth integrands. See alloc_autobuffer for how to pre-evaluate a buffer for autosymptr for use across calls with compatible integrands.\n\n\n\n\n\n","category":"type"},{"location":"integration/#AutoBZCore.PTR_IAI","page":"Integration","title":"AutoBZCore.PTR_IAI","text":"PTR_IAI(; ptr=PTR(), iai=IAI())\n\nMulti-algorithm that returns an IAI calculation with an abstol determined from the given reltol and a PTR estimate, I, as reltol*norm(I). This addresses the issue that IAI does not currently use a globally-adaptive algorithm and may not have the expected scaling with localization length unless an abstol is used since computational effort may be wasted via a reltol with the naive nested_quadgk.\n\n\n\n\n\n","category":"type"},{"location":"integration/#AutoBZCore.AutoPTR_IAI","page":"Integration","title":"AutoBZCore.AutoPTR_IAI","text":"AutoPTR_IAI(; reltol=1.0, ptr=AutoPTR(), iai=IAI())\n\nMulti-algorithm that returns an IAI calculation with an abstol determined from an AutoPTR estimate, I, computed to reltol precision, and the rtol given to the solver as rtol*norm(I). This addresses the issue that IAI does not currently use a globally-adaptive algorithm and may not have the expected scaling with localization length unless an abstol is used since computational effort may be wasted via a reltol with the naive nested_quadgk.\n\n\n\n\n\n","category":"type"},{"location":"integration/#AutoBZCore.TAI","page":"Integration","title":"AutoBZCore.TAI","text":"TAI(; rule=HCubatureJL())\n\nTree-adaptive integration using hcubature from HCubature.jl. This routine is limited to integration over hypercube domains and may not use all symmetries.\n\n\n\n\n\n","category":"type"},{"location":"integration/#Allocations-for-algorithms","page":"Integration","title":"Allocations for algorithms","text":"","category":"section"},{"location":"integration/","page":"Integration","title":"Integration","text":"In practice, allocating memory for an algorithm can help improve its performance. This is particularly noticeable for PTR, where one of the main optimizations is to store the Fourier series evaluated on the PTR grid for reuse across multiple compatible calls. The routines below show how to pre-evaluate or pre-allocate the memory necessary for different algorithms.","category":"page"},{"location":"integration/","page":"Integration","title":"Integration","text":"AutoBZCore.alloc_rule\nAutoBZCore.alloc_autobuffer\nAutoBZCore.alloc_segbufs","category":"page"},{"location":"integration/#AutoBZCore.alloc_rule","page":"Integration","title":"AutoBZCore.alloc_rule","text":"alloc_rule(f::AbstractFourierSeries, ::Type, syms)\n\nCompute the values of f on the PTR grid as well as the quadrature weights for the given syms to use across multiple compatible calls of the PTR algorithm.\n\n\n\n\n\n","category":"function"},{"location":"integration/#AutoSymPTR.alloc_autobuffer","page":"Integration","title":"AutoSymPTR.alloc_autobuffer","text":"alloc_autobuffer(f::AbstractFourierSeries, ::Type, syms)\n\nInitialize an empty buffer of PTR rules with pre-evaluated Fourier series evaluated on a domain of type T with symmetries syms to use across multiple compatible calls of the AutoPTR algorithm.\n\n\n\n\n\n","category":"function"},{"location":"integration/#IteratedIntegration.alloc_segbufs","page":"Integration","title":"IteratedIntegration.alloc_segbufs","text":"alloc_segbufs(coefficient_type, range_type, norm_type, ndim)\n\nAllocate a segment buffer for multiple compatible calls to IAI. Typically coefficient_type would be eltype(bz), range_type would be the return type of the integrand, and norm_type would be Base.promote_op(norm, range_type). ndim should be the number of dimensions of integration.\n\n\n\n\n\n","category":"function"},{"location":"integration/#Parallelization","page":"Integration","title":"Parallelization","text":"","category":"section"},{"location":"integration/","page":"Integration","title":"Integration","text":"This package parallelizes k-sums in the PTR and AutoPTR routines by default, which gives good multi-threaded performance for those algorithms when the number of k-points is large. On the other hand, if the number of parameter points for which you would like to evaluate an integral is large, then parameter-parallelization is an effective strategy and done by the routines below.","category":"page"},{"location":"integration/","page":"Integration","title":"Integration","text":"batchsolve\nAutoBZCore.batchparam","category":"page"},{"location":"integration/#AutoBZCore.batchsolve","page":"Integration","title":"AutoBZCore.batchsolve","text":"batchsolve(f, ps, [T=Base.promote_op(f, eltype(ps))]; nthreads=Threads.nthreads())\n\nEvaluate the IntegralSolver f at each of the parameters ps in parallel. Returns a vector containing the evaluated integrals I. This is a form of multithreaded broadcasting.\n\n\n\n\n\n","category":"function"},{"location":"integration/#AutoBZCore.batchparam","page":"Integration","title":"AutoBZCore.batchparam","text":"batchparam(ps, nthreads)\n\nIf the cost of a calculation smoothly varies with the parameters ps, then batch ps into nthreads groups where the ith element of group j is ps[j+(i-1)*nthreads]\n\n\n\n\n\n","category":"function"},{"location":"bz/#Brillouin-zones","page":"Brillouin zones","title":"Brillouin zones","text":"","category":"section"},{"location":"bz/","page":"Brillouin zones","title":"Brillouin zones","text":"The first Brillouin zone (FBZ) or full BZ, is the domain of integration for many quantum-mechanical observables in crystalline systems with translation symmetry. In systems with additional point-group symmetries, the symmetries can be used to down-fold the FBZ onto the irreducible Brillouin zone (IBZ) that can be used to reduce the computational cost by a factor of at most 2^d d in d spatial dimensions. While the FBZ is isomorphic to a hypercube, the IBZ is a polytope. The following type stores the data used by various algorithms to do IBZ integration.","category":"page"},{"location":"bz/","page":"Brillouin zones","title":"Brillouin zones","text":"SymmetricBZ\nFullBZ","category":"page"},{"location":"bz/#AutoBZCore.SymmetricBZ","page":"Brillouin zones","title":"AutoBZCore.SymmetricBZ","text":"SymmetricBZ(A, B, lims::AbstractLimits, syms; atol=sqrt(eps()))\n\nData type representing a Brillouin zone reduced by a set of symmetries, syms with iterated integration limits lims, both of which are assumed to be in the lattice basis (since the Fourier series is). A and B should be identically-sized square matrices containing the real and reciprocal basis vectors in their columns. \n\nnote: Convention\nThis type assumes all integration limit data is in the reciprocal lattice basis with fractional coordinates, where the FBZ is just the hypercube spanned by the vertices (0,…,0) & (1,…,1). If necessary, use A or B to rotate these quantities into the convention.\n\nlims should be limits compatible with IteratedIntegration.jl. syms should be an iterable collection of point group symmetries compatible with AutoSymPTR.jl.\n\n\n\n\n\n","category":"type"},{"location":"bz/#AutoBZCore.FullBZ","page":"Brillouin zones","title":"AutoBZCore.FullBZ","text":"FullBZ(A, B=canonical_reciprocal_basis(A); atol=sqrt(eps()))\n\nConstructs a SymmetricBZ with trivial symmetries.\n\n\n\n\n\n","category":"function"},{"location":"bz/#Integration-limits","page":"Brillouin zones","title":"Integration limits","text":"","category":"section"},{"location":"bz/","page":"Brillouin zones","title":"Brillouin zones","text":"The IAI algorithm can do IBZ integration with knowledge of the convex hull of the IBZ. The calc_ibz routine in SymmetryReduceBZ.jl does exactly this step. Then polyhedral manipulation algorithms can be used to do this step (search for PolyhedralLimits in IteratedIntegration.jl).","category":"page"},{"location":"bz/#Lattice-symmetries","page":"Brillouin zones","title":"Lattice symmetries","text":"","category":"section"},{"location":"bz/","page":"Brillouin zones","title":"Brillouin zones","text":"The PTR and AutoPTR algorithms can do IBZ integration (also known as Monkhorst-Pack integration) simply with the crystallographic point group. This can be provided as a vector of the point group operators in the syms argument of SymmetricBZ.","category":"page"},{"location":"bz/#Symmetry-representations","page":"Brillouin zones","title":"Symmetry representations","text":"","category":"section"},{"location":"bz/","page":"Brillouin zones","title":"Brillouin zones","text":"The result of the integral on the IBZ still needs to be mapped to the FBZ. The SymRep trait is provided so that the caller can specify the symmetry representation of their integrand to automate this mapping.","category":"page"},{"location":"bz/","page":"Brillouin zones","title":"Brillouin zones","text":"SymRep\nAbstractSymRep\nFaithfulRep","category":"page"},{"location":"bz/#AutoBZCore.SymRep","page":"Brillouin zones","title":"AutoBZCore.SymRep","text":"SymRep(f)\n\nSymRep specifies the symmetry representation of the integral of the function f. When you define a new integrand, you can choose to implement this trait to specify how the integral is transformed under the symmetries of the lattice in order to map the integral of f on the IBZ to the result for the FBZ.\n\nNew types for SymRep should also extend a corresponding method for AutoBZCore.symmetrize_.\n\n\n\n\n\n","category":"function"},{"location":"bz/#AutoBZCore.AbstractSymRep","page":"Brillouin zones","title":"AutoBZCore.AbstractSymRep","text":"AbstractSymRep\n\nAbstract supertype of symmetry representation traits.\n\n\n\n\n\n","category":"type"},{"location":"bz/#AutoBZCore.FaithfulRep","page":"Brillouin zones","title":"AutoBZCore.FaithfulRep","text":"FaithfulRep\n\nAbstract supertype of traits for faithful symmetry representations.\n\n\n\n\n\n","category":"type"},{"location":"bz/","page":"Brillouin zones","title":"Brillouin zones","text":"The following representations are provided out-of-the box:","category":"page"},{"location":"bz/","page":"Brillouin zones","title":"Brillouin zones","text":"TrivialRep\nLatticeRep\nUnknownRep","category":"page"},{"location":"bz/#AutoBZCore.TrivialRep","page":"Brillouin zones","title":"AutoBZCore.TrivialRep","text":"TrivialRep()\n\nSymmetry representation of objects with trivial transformation under the group.\n\n\n\n\n\n","category":"type"},{"location":"bz/#AutoBZCore.LatticeRep","page":"Brillouin zones","title":"AutoBZCore.LatticeRep","text":"LatticeRep()\n\nSymmetry representation of objects that transform under the group action in the same way as the lattice.\n\n\n\n\n\n","category":"type"},{"location":"bz/#AutoBZCore.UnknownRep","page":"Brillouin zones","title":"AutoBZCore.UnknownRep","text":"UnknownRep()\n\nFallback symmetry representation for array types without a user-defined SymRep.\n\n\n\n\n\n","category":"type"},{"location":"bz/#User-defined-SymReps","page":"Brillouin zones","title":"User-defined SymReps","text":"","category":"section"},{"location":"bz/","page":"Brillouin zones","title":"Brillouin zones","text":"These are the methods to be aware of extending to implement the action of a symmetry group for mapping an integral from the IBZ to the FBZ.","category":"page"},{"location":"bz/","page":"Brillouin zones","title":"Brillouin zones","text":"AutoBZCore.symmetrize\nAutoBZCore.symmetrize_","category":"page"},{"location":"bz/#AutoBZCore.symmetrize","page":"Brillouin zones","title":"AutoBZCore.symmetrize","text":"symmetrize(f, ::SymmetricBZ, xs...)\nsymmetrize(f, ::SymmetricBZ, x::Union{Number,AbstractArray{<:Any,0}})\n\nTransform x by the symmetries of the parametrization used to reduce the domain, thus mapping the value of x on the parametrization to the full domain.\n\n\n\n\n\n","category":"function"},{"location":"bz/#AutoBZCore.symmetrize_","page":"Brillouin zones","title":"AutoBZCore.symmetrize_","text":"symmetrize_(rep::AbstractSymRep, bz::SymmetricBZ, x)\n\nTransform x under representation rep using the symmetries in bz to obtain the result of an integral on the FBZ from x, which was calculated on the IBZ.\n\n\n\n\n\n","category":"function"},{"location":"bz/","page":"Brillouin zones","title":"Brillouin zones","text":"If you are an expert on the symmetry representations of Wannier orbitals or Bloch bands and can offer assistance in automating the IBZ to FBZ mapping, please contact the developers by opening a Github issue or pr.","category":"page"},{"location":"#AutoBZCore.jl","page":"Home","title":"AutoBZCore.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AutoBZCore","category":"page"},{"location":"#AutoBZCore","page":"Home","title":"AutoBZCore","text":"The package providing the functionality and abstractions for AutoBZ.jl. It provides both SymmetricBZ, which is a type that stores information about the Brillouin zone (BZ), and IntegralSolver, a type that provides a functor interface to parametrize IntegralProblems as defined by Integrals.jl. The package also provides the optimized FourierIntegrand. The package integrates with FourierSeriesEvaluators.jl, IteratedIntegration.jl, and AutoSymPTR.jl to provide a generic interface to efficient algorithms for BZ integration.\n\nFor example, computing the local Green's function can be done as follows:\n\nusing LinearAlgebra\nusing FourierSeriesEvaluators\nusing AutoBZCore\n\ngloc_integrand(h_k; η, ω) = inv(complex(ω,η)*I-h_k)     # define integrand evaluator\nh = FourierSeries([0.5, 0.0, 0.5]; offset=-2)           # construct cos(k) 1D integer lattice Hamiltonian\nbz = FullBZ(2pi*I(1))                                   # construct BZ from lattice vectors A=2pi*I\nintegrand = FourierIntegrand(gloc_integrand, h, η=0.1)    # construct integrand with Fourier series h and parameter η=0.1\nalg = IAI()                                             # choose integration algorithm (also AutoPTR() and PTR())\ngloc = IntegralSolver(integrand, bz, alg; abstol=1e-3)  # construct a solver for gloc to within specified tolerance\ngloc(ω=0.0)                                               # evaluate gloc at frequency ω=0.0\n\nnote: Assumptions\nAutoBZCore assumes that all calculations occur in the reciprocal lattice basis, since that is the basis in which Wannier interpolants are most efficiently described. See SymmetricBZ for details.\n\n\n\n\n\n","category":"module"}]
}
