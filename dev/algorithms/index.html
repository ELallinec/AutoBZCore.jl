<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithms · AutoBZCore.jl</title><meta name="title" content="Algorithms · AutoBZCore.jl"/><meta property="og:title" content="Algorithms · AutoBZCore.jl"/><meta property="twitter:title" content="Algorithms · AutoBZCore.jl"/><meta name="description" content="Documentation for AutoBZCore.jl."/><meta property="og:description" content="Documentation for AutoBZCore.jl."/><meta property="twitter:description" content="Documentation for AutoBZCore.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AutoBZCore.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../problems/">Problems</a></li><li><a class="tocitem" href="../integrands/">Integrands</a></li><li class="is-active"><a class="tocitem" href>Algorithms</a><ul class="internal"><li><a class="tocitem" href="#Quadrature"><span>Quadrature</span></a></li><li><a class="tocitem" href="#Cubature"><span>Cubature</span></a></li><li><a class="tocitem" href="#Meta-algorithms"><span>Meta-algorithms</span></a></li><li class="toplevel"><a class="tocitem" href="#BZ-specific-integral-algorithms"><span>BZ-specific integral algorithms</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><a class="tocitem" href="../extensions/">Extensions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/lxvm/AutoBZCore.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/lxvm/AutoBZCore.jl/blob/main/docs/src/algorithms.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Integral-algorithms"><a class="docs-heading-anchor" href="#Integral-algorithms">Integral algorithms</a><a id="Integral-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Integral-algorithms" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.IntegralAlgorithm" href="#AutoBZCore.IntegralAlgorithm"><code>AutoBZCore.IntegralAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntegralAlgorithm</code></pre><p>Abstract supertype for integration algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/8d1024cea5cb943ebfac9baf15a4c2113f34a1b3/src/interfaces.jl#L7-L11">source</a></section></article><h2 id="Quadrature"><a class="docs-heading-anchor" href="#Quadrature">Quadrature</a><a id="Quadrature-1"></a><a class="docs-heading-anchor-permalink" href="#Quadrature" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.QuadratureFunction" href="#AutoBZCore.QuadratureFunction"><code>AutoBZCore.QuadratureFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuadratureFunction(; fun=trapz, npt=50, nthreads=Threads.nthreads())</code></pre><p>Quadrature rule for the standard interval [-1,1] computed from a function <code>x, w = fun(npt)</code>. The nodes and weights should be set so the integral of <code>f</code> on [-1,1] is <code>sum(w .* f.(x))</code>. The default quadrature rule is <a href="../reference/#AutoBZCore.trapz"><code>trapz</code></a>, although other packages provide rules, e.g.</p><pre><code class="nohighlight hljs">using FastGaussQuadrature
alg = QuadratureFunction(fun=gausslegendre, npt=100)</code></pre><p><code>nthreads</code> sets the numbers of threads used to parallelize the quadrature only when the integrand is a <a href="../integrands/#AutoBZCore.BatchIntegrand"><code>BatchIntegrand</code></a>, in which case the user must parallelize the integrand evaluations. For no threading set <code>nthreads=1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/8d1024cea5cb943ebfac9baf15a4c2113f34a1b3/src/algorithms.jl#L142-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.QuadGKJL" href="#AutoBZCore.QuadGKJL"><code>AutoBZCore.QuadGKJL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuadGKJL(; order = 7, norm = norm)</code></pre><p>Duplicate of the QuadGKJL provided by Integrals.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/8d1024cea5cb943ebfac9baf15a4c2113f34a1b3/src/algorithms.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.AuxQuadGKJL" href="#AutoBZCore.AuxQuadGKJL"><code>AutoBZCore.AuxQuadGKJL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AuxQuadGKJL(; order = 7, norm = norm)</code></pre><p>Generalization of the QuadGKJL provided by Integrals.jl that allows for <code>AuxValue</code>d integrands for auxiliary integration and multi-threaded evaluation with the <code>batch</code> argument to <code>IntegralProblem</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/8d1024cea5cb943ebfac9baf15a4c2113f34a1b3/src/algorithms.jl#L195-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.ContQuadGKJL" href="#AutoBZCore.ContQuadGKJL"><code>AutoBZCore.ContQuadGKJL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ContQuadGKJL(; order = 7, norm = norm, rho = 1.0, rootmeth = IteratedIntegration.ContQuadGK.NewtonDeflation())</code></pre><p>A 1d contour deformation quadrature scheme for scalar, complex-valued integrands. It defaults to regular <code>quadgk</code> behavior on the real axis, but if it finds a root of 1/f nearby, in the sense of Bernstein ellipse for the standard segment <code>[-1,1]</code> with semiaxes <code>cosh(rho)</code> and <code>sinh(rho)</code>, on either the upper/lower half planes, then it dents the contour away from the presumable pole.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/8d1024cea5cb943ebfac9baf15a4c2113f34a1b3/src/algorithms.jl#L242-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.MeroQuadGKJL" href="#AutoBZCore.MeroQuadGKJL"><code>AutoBZCore.MeroQuadGKJL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MeroQuadGKJL(; order = 7, norm = norm, rho = 1.0, rootmeth = IteratedIntegration.MeroQuadGK.NewtonDeflation())</code></pre><p>A 1d pole subtraction quadrature scheme for scalar, complex-valued integrands that are meromorphic. It defaults to regular <code>quadgk</code> behavior on the real axis, but if it finds nearby roots of 1/f, in the sense of Bernstein ellipse for the standard segment <code>[-1,1]</code> with semiaxes <code>cosh(rho)</code> and <code>sinh(rho)</code>, it attempts pole subtraction on that segment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/8d1024cea5cb943ebfac9baf15a4c2113f34a1b3/src/algorithms.jl#L291-L298">source</a></section></article><h2 id="Cubature"><a class="docs-heading-anchor" href="#Cubature">Cubature</a><a id="Cubature-1"></a><a class="docs-heading-anchor-permalink" href="#Cubature" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.HCubatureJL" href="#AutoBZCore.HCubatureJL"><code>AutoBZCore.HCubatureJL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HCubatureJL(; norm=norm, initdiv=1)</code></pre><p>A copy of <code>HCubatureJL</code> from Integrals.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/8d1024cea5cb943ebfac9baf15a4c2113f34a1b3/src/algorithms.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.MonkhorstPack" href="#AutoBZCore.MonkhorstPack"><code>AutoBZCore.MonkhorstPack</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MonkhorstPack(; npt=50, syms=nothing, nthreads=Threads.nthreads())</code></pre><p>Periodic trapezoidal rule with a fixed number of k-points per dimension, <code>npt</code>, using the <code>PTR</code> rule from <a href="https://github.com/lxvm/AutoSymPTR.jl">AutoSymPTR.jl</a>. <code>nthreads</code> sets the numbers of threads used to parallelize the quadrature only when the integrand is a <a href="../integrands/#AutoBZCore.BatchIntegrand"><code>BatchIntegrand</code></a>, in which case the user must parallelize the integrand evaluations. For no threading set <code>nthreads=1</code>. <strong>The caller should check that the integral is converged w.r.t. <code>npt</code></strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/8d1024cea5cb943ebfac9baf15a4c2113f34a1b3/src/algorithms.jl#L332-L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.AutoSymPTRJL" href="#AutoBZCore.AutoSymPTRJL"><code>AutoBZCore.AutoSymPTRJL</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AutoSymPTRJL(; norm=norm, a=1.0, nmin=50, nmax=1000, n₀=6, Δn=log(10), keepmost=2, nthreads=Threads.nthreads())</code></pre><p>Periodic trapezoidal rule with automatic convergence to tolerances passed to the solver with respect to <code>norm</code> using the routine <code>autosymptr</code> from <a href="https://github.com/lxvm/AutoSymPTR.jl">AutoSymPTR.jl</a>. <code>nthreads</code> sets the numbers of threads used to parallelize the quadrature only when the integrand is a <a href="../integrands/#AutoBZCore.BatchIntegrand"><code>BatchIntegrand</code></a>, in which case the user must parallelize the integrand evaluations. For no threading set <code>nthreads=1</code>. <strong>This algorithm is the most efficient for smooth integrands</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/8d1024cea5cb943ebfac9baf15a4c2113f34a1b3/src/algorithms.jl#L382-L392">source</a></section></article><h2 id="Meta-algorithms"><a class="docs-heading-anchor" href="#Meta-algorithms">Meta-algorithms</a><a id="Meta-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Meta-algorithms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.NestedQuad" href="#AutoBZCore.NestedQuad"><code>AutoBZCore.NestedQuad</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NestedQuad(alg::IntegralAlgorithm)
NestedQuad(algs::IntegralAlgorithm...)</code></pre><p>Nested integration by repeating one quadrature algorithm or composing a list of algorithms. The domain of integration must be an <code>AbstractIteratedLimits</code> from the IteratedIntegration.jl package. Analogous to <code>nested_quad</code> from IteratedIntegration.jl. The integrand should expect <code>SVector</code> inputs. Do not use this for very high-dimensional integrals, since the compilation time scales very poorly with respect to dimensionality. In order to improve the compilation time, FunctionWrappers.jl is used to enforce type stability of the integrand, so you should always pick the widest integration limit type so that inference works properly. For example, if <a href="#AutoBZCore.ContQuadGKJL"><code>ContQuadGKJL</code></a> is used as an algorithm in the nested scheme, then the limits of integration should be made complex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/8d1024cea5cb943ebfac9baf15a4c2113f34a1b3/src/algorithms.jl#L436-L449">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.EvalCounter" href="#AutoBZCore.EvalCounter"><code>AutoBZCore.EvalCounter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EvalCounter(::IntegralAlgorithm)</code></pre><p>An algorithm which counts the evaluations used by another algorithm. The count is stored in the <code>sol.numevals</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/8d1024cea5cb943ebfac9baf15a4c2113f34a1b3/src/algorithms.jl#L656-L661">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.AbsoluteEstimate" href="#AutoBZCore.AbsoluteEstimate"><code>AutoBZCore.AbsoluteEstimate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbsoluteEstimate(est_alg, abs_alg; kws...)</code></pre><p>Most algorithms are efficient when using absolute error tolerances, but how do you know the size of the integral? One option is to estimate it using second algorithm.</p><p>A multi-algorithm to estimate an integral using an <code>est_alg</code> to generate a rough estimate of the integral that is combined with a user&#39;s relative tolerance to re-calculate the integral to higher accuracy using the <code>abs_alg</code>. The keywords passed to the algorithm may include <code>reltol</code>, <code>abstol</code> and <code>maxiters</code> and are given to the <code>est_alg</code> solver. They should limit the amount of work of <code>est_alg</code> so as to only generate an order-of-magnitude estimate of the integral. The tolerances passed to <code>abs_alg</code> are <code>abstol=max(abstol,reltol*norm(I))</code> and <code>reltol=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/8d1024cea5cb943ebfac9baf15a4c2113f34a1b3/src/algorithms.jl#L614-L627">source</a></section></article><h1 id="BZ-specific-integral-algorithms"><a class="docs-heading-anchor" href="#BZ-specific-integral-algorithms">BZ-specific integral algorithms</a><a id="BZ-specific-integral-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#BZ-specific-integral-algorithms" title="Permalink"></a></h1><p>In order to make algorithms domain-agnostic, the BZ loaded from <a href="../reference/#AutoBZCore.load_bz"><code>load_bz</code></a> can be called with the algorithms below, which are wrappers for algorithms above with the additional capability of mapping integrals over the IBZ to the FBZ.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.AutoBZAlgorithm" href="#AutoBZCore.AutoBZAlgorithm"><code>AutoBZCore.AutoBZAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AutoBZAlgorithm</code></pre><p>Abstract supertype for Brillouin zone integration algorithms. All integration problems on the BZ get rescaled to fractional coordinates so that the Brillouin zone becomes <code>[0,1]^d</code>, and integrands should have this periodicity. If the integrand depends on the Brillouin zone basis, then it may have to be transformed to the Cartesian coordinates as a post-processing step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/8d1024cea5cb943ebfac9baf15a4c2113f34a1b3/src/brillouin.jl#L284-L292">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.IAI" href="#AutoBZCore.IAI"><code>AutoBZCore.IAI</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IAI(alg::IntegralAlgorithm=AuxQuadGKJL())
IAI(algs::IntegralAlgorithm...)</code></pre><p>Iterated-adaptive integration using <code>nested_quad</code> from <a href="https://github.com/lxvm/IteratedIntegration.jl">IteratedIntegration.jl</a>. <strong>This algorithm is the most efficient for localized integrands</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/8d1024cea5cb943ebfac9baf15a4c2113f34a1b3/src/brillouin.jl#L316-L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.TAI" href="#AutoBZCore.TAI"><code>AutoBZCore.TAI</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TAI(; norm=norm, initdivs=1)</code></pre><p>Tree-adaptive integration using <code>hcubature</code> from <a href="https://github.com/JuliaMath/HCubature.jl">HCubature.jl</a>. This routine is limited to integration over hypercube domains and may not use all symmetries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/8d1024cea5cb943ebfac9baf15a4c2113f34a1b3/src/brillouin.jl#L378-L384">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.PTR" href="#AutoBZCore.PTR"><code>AutoBZCore.PTR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PTR(; npt=50, parallel=nothing)</code></pre><p>Periodic trapezoidal rule with a fixed number of k-points per dimension, <code>npt</code>, using the routine <code>ptr</code> from <a href="https://github.com/lxvm/AutoSymPTR.jl">AutoSymPTR.jl</a>. <strong>The caller should check that the integral is converged w.r.t. <code>npt</code></strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/8d1024cea5cb943ebfac9baf15a4c2113f34a1b3/src/brillouin.jl#L335-L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.AutoPTR" href="#AutoBZCore.AutoPTR"><code>AutoBZCore.AutoPTR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AutoPTR(; norm=norm, a=1.0, nmin=50, nmax=1000, n₀=6, Δn=log(10), keepmost=2, parallel=nothing)</code></pre><p>Periodic trapezoidal rule with automatic convergence to tolerances passed to the solver with respect to <code>norm</code> using the routine <code>autosymptr</code> from <a href="https://github.com/lxvm/AutoSymPTR.jl">AutoSymPTR.jl</a>. <strong>This algorithm is the most efficient for smooth integrands</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/8d1024cea5cb943ebfac9baf15a4c2113f34a1b3/src/brillouin.jl#L353-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.PTR_IAI" href="#AutoBZCore.PTR_IAI"><code>AutoBZCore.PTR_IAI</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">PTR_IAI(; ptr=PTR(), iai=IAI())</code></pre><p>Multi-algorithm that returns an <code>IAI</code> calculation with an <code>abstol</code> determined from the given <code>reltol</code> and a <code>PTR</code> estimate, <code>I</code>, as <code>reltol*norm(I)</code>. This addresses the issue that <code>IAI</code> does not currently use a globally-adaptive algorithm and may not have the expected scaling with localization length unless an <code>abstol</code> is used since computational effort may be wasted via a <code>reltol</code> with the naive <code>nested_quadgk</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/8d1024cea5cb943ebfac9baf15a4c2113f34a1b3/src/brillouin.jl#L398-L407">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.AutoPTR_IAI" href="#AutoBZCore.AutoPTR_IAI"><code>AutoBZCore.AutoPTR_IAI</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AutoPTR_IAI(; reltol=1.0, ptr=AutoPTR(), iai=IAI())</code></pre><p>Multi-algorithm that returns an <code>IAI</code> calculation with an <code>abstol</code> determined from an <code>AutoPTR</code> estimate, <code>I</code>, computed to <code>reltol</code> precision, and the <code>rtol</code> given to the solver as <code>abstol=rtol*norm(I)</code>. This addresses the issue that <code>IAI</code> does not currently use a globally-adaptive algorithm and may not have the expected scaling with localization length unless an <code>abstol</code> is used since computational effort may be wasted via a <code>reltol</code> with the naive <code>nested_quadgk</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/8d1024cea5cb943ebfac9baf15a4c2113f34a1b3/src/brillouin.jl#L411-L421">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../integrands/">« Integrands</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Tuesday 14 November 2023 00:25">Tuesday 14 November 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
