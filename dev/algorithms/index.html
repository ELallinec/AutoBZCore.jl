<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithms · AutoBZCore.jl</title><meta name="title" content="Algorithms · AutoBZCore.jl"/><meta property="og:title" content="Algorithms · AutoBZCore.jl"/><meta property="twitter:title" content="Algorithms · AutoBZCore.jl"/><meta name="description" content="Documentation for AutoBZCore.jl."/><meta property="og:description" content="Documentation for AutoBZCore.jl."/><meta property="twitter:description" content="Documentation for AutoBZCore.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AutoBZCore.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../problems/">Problems</a></li><li><a class="tocitem" href="../integrands/">Integrands</a></li><li class="is-active"><a class="tocitem" href>Algorithms</a><ul class="internal"><li><a class="tocitem" href="#IntegralProblem-algorithms"><span><code>IntegralProblem</code> algorithms</span></a></li><li><a class="tocitem" href="#AutoBZProblem-algorithms"><span><code>AutoBZProblem</code> algorithms</span></a></li><li><a class="tocitem" href="#DOSProblem-algorithms"><span><code>DOSProblem</code> algorithms</span></a></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><a class="tocitem" href="../extensions/">Extensions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/lxvm/AutoBZCore.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/lxvm/AutoBZCore.jl/blob/main/docs/src/algorithms.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h1><h2 id="IntegralProblem-algorithms"><a class="docs-heading-anchor" href="#IntegralProblem-algorithms"><code>IntegralProblem</code> algorithms</a><a id="IntegralProblem-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#IntegralProblem-algorithms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.IntegralAlgorithm" href="#AutoBZCore.IntegralAlgorithm"><code>AutoBZCore.IntegralAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntegralAlgorithm</code></pre><p>Abstract supertype for integration algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/27d1a4e3e828093609c9ed189a2de006f33bc85d/src/interfaces.jl#L126-L130">source</a></section></article><h3 id="Quadrature"><a class="docs-heading-anchor" href="#Quadrature">Quadrature</a><a id="Quadrature-1"></a><a class="docs-heading-anchor-permalink" href="#Quadrature" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.QuadratureFunction" href="#AutoBZCore.QuadratureFunction"><code>AutoBZCore.QuadratureFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuadratureFunction(; fun=trapz, npt=50, nthreads=1)</code></pre><p>Quadrature rule for the standard interval [-1,1] computed from a function <code>x, w = fun(npt)</code>. The nodes and weights should be set so the integral of <code>f</code> on [-1,1] is <code>sum(w .* f.(x))</code>. The default quadrature rule is <a href="../reference/#AutoBZCore.trapz"><code>trapz</code></a>, although other packages provide rules, e.g.</p><pre><code class="nohighlight hljs">using FastGaussQuadrature
alg = QuadratureFunction(fun=gausslegendre, npt=100)</code></pre><p><code>nthreads</code> sets the numbers of threads used to parallelize the quadrature only when the integrand is a , in which case the user must parallelize the integrand evaluations. For no threading set <code>nthreads=1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/27d1a4e3e828093609c9ed189a2de006f33bc85d/src/algorithms.jl#L157-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.QuadGKJL" href="#AutoBZCore.QuadGKJL"><code>AutoBZCore.QuadGKJL</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuadGKJL(; order = 7, norm = norm)</code></pre><p>Duplicate of the QuadGKJL provided by Integrals.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/27d1a4e3e828093609c9ed189a2de006f33bc85d/src/algorithms.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.AuxQuadGKJL" href="#AutoBZCore.AuxQuadGKJL"><code>AutoBZCore.AuxQuadGKJL</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AuxQuadGKJL(; order = 7, norm = norm)</code></pre><p>Generalization of the QuadGKJL provided by Integrals.jl that allows for <code>AuxValue</code>d integrands for auxiliary integration and multi-threaded evaluation with the <code>batch</code> argument to <code>IntegralProblem</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/27d1a4e3e828093609c9ed189a2de006f33bc85d/src/algorithms_iterated.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.ContQuadGKJL" href="#AutoBZCore.ContQuadGKJL"><code>AutoBZCore.ContQuadGKJL</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ContQuadGKJL(; order = 7, norm = norm, rho = 1.0, rootmeth = IteratedIntegration.ContQuadGK.NewtonDeflation())</code></pre><p>A 1d contour deformation quadrature scheme for scalar, complex-valued integrands. It defaults to regular <code>quadgk</code> behavior on the real axis, but if it finds a root of 1/f nearby, in the sense of Bernstein ellipse for the standard segment <code>[-1,1]</code> with semiaxes <code>cosh(rho)</code> and <code>sinh(rho)</code>, on either the upper/lower half planes, then it dents the contour away from the presumable pole.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/27d1a4e3e828093609c9ed189a2de006f33bc85d/src/algorithms_iterated.jl#L72-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.MeroQuadGKJL" href="#AutoBZCore.MeroQuadGKJL"><code>AutoBZCore.MeroQuadGKJL</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MeroQuadGKJL(; order = 7, norm = norm, rho = 1.0, rootmeth = IteratedIntegration.MeroQuadGK.NewtonDeflation())</code></pre><p>A 1d pole subtraction quadrature scheme for scalar, complex-valued integrands that are meromorphic. It defaults to regular <code>quadgk</code> behavior on the real axis, but if it finds nearby roots of 1/f, in the sense of Bernstein ellipse for the standard segment <code>[-1,1]</code> with semiaxes <code>cosh(rho)</code> and <code>sinh(rho)</code>, it attempts pole subtraction on that segment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/27d1a4e3e828093609c9ed189a2de006f33bc85d/src/algorithms_iterated.jl#L137-L144">source</a></section></article><h3 id="Cubature"><a class="docs-heading-anchor" href="#Cubature">Cubature</a><a id="Cubature-1"></a><a class="docs-heading-anchor-permalink" href="#Cubature" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.HCubatureJL" href="#AutoBZCore.HCubatureJL"><code>AutoBZCore.HCubatureJL</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HCubatureJL(; norm=norm, initdiv=1)</code></pre><p>Multi-dimensional h-adaptive cubature from HCubature.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/27d1a4e3e828093609c9ed189a2de006f33bc85d/src/algorithms.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.MonkhorstPack" href="#AutoBZCore.MonkhorstPack"><code>AutoBZCore.MonkhorstPack</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MonkhorstPack(; npt=50, syms=nothing, nthreads=1)</code></pre><p>Periodic trapezoidal rule with a fixed number of k-points per dimension, <code>npt</code>, using the <code>PTR</code> rule from <a href="https://github.com/lxvm/AutoSymPTR.jl">AutoSymPTR.jl</a>. <code>nthreads</code> sets the numbers of threads used to parallelize the quadrature only when the integrand is a , in which case the user must parallelize the integrand evaluations. For no threading set <code>nthreads=1</code>. <strong>The caller should check that the integral is converged w.r.t. <code>npt</code></strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/27d1a4e3e828093609c9ed189a2de006f33bc85d/src/algorithms_autosymptr.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.AutoSymPTRJL" href="#AutoBZCore.AutoSymPTRJL"><code>AutoBZCore.AutoSymPTRJL</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AutoSymPTRJL(; norm=norm, a=1.0, nmin=50, nmax=1000, n₀=6, Δn=log(10), keepmost=2, nthreads=1)</code></pre><p>Periodic trapezoidal rule with automatic convergence to tolerances passed to the solver with respect to <code>norm</code> using the routine <code>autosymptr</code> from <a href="https://github.com/lxvm/AutoSymPTR.jl">AutoSymPTR.jl</a>. <code>nthreads</code> sets the numbers of threads used to parallelize the quadrature only when the integrand is a  in which case the user must parallelize the integrand evaluations. For no threading set <code>nthreads=1</code>. <strong>This algorithm is the most efficient for smooth integrands</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/27d1a4e3e828093609c9ed189a2de006f33bc85d/src/algorithms_autosymptr.jl#L47-L57">source</a></section></article><h3 id="Meta-algorithms"><a class="docs-heading-anchor" href="#Meta-algorithms">Meta-algorithms</a><a id="Meta-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Meta-algorithms" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.NestedQuad" href="#AutoBZCore.NestedQuad"><code>AutoBZCore.NestedQuad</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NestedQuad(alg::IntegralAlgorithm)
NestedQuad(algs::IntegralAlgorithm...)</code></pre><p>Nested integration by repeating one quadrature algorithm or composing a list of algorithms. The domain of integration must be an <code>AbstractIteratedLimits</code> from the IteratedIntegration.jl package. Analogous to <code>nested_quad</code> from IteratedIntegration.jl. The integrand should expect <code>SVector</code> inputs. Do not use this for very high-dimensional integrals, since the compilation time scales very poorly with respect to dimensionality. In order to improve the compilation time, FunctionWrappers.jl is used to enforce type stability of the integrand, so you should always pick the widest integration limit type so that inference works properly. For example, if <a href="#AutoBZCore.ContQuadGKJL"><code>ContQuadGKJL</code></a> is used as an algorithm in the nested scheme, then the limits of integration should be made complex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/27d1a4e3e828093609c9ed189a2de006f33bc85d/src/algorithms_meta.jl#L1-L14">source</a></section></article><h2 id="AutoBZProblem-algorithms"><a class="docs-heading-anchor" href="#AutoBZProblem-algorithms"><code>AutoBZProblem</code> algorithms</a><a id="AutoBZProblem-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#AutoBZProblem-algorithms" title="Permalink"></a></h2><p>In order to make algorithms domain-agnostic, the BZ loaded from <a href="../reference/#AutoBZCore.load_bz"><code>load_bz</code></a> can be called with the algorithms below, which are aliases for algorithms above</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.AutoBZAlgorithm" href="#AutoBZCore.AutoBZAlgorithm"><code>AutoBZCore.AutoBZAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AutoBZAlgorithm</code></pre><p>Abstract supertype for Brillouin zone integration algorithms. All integration problems on the BZ get rescaled to fractional coordinates so that the Brillouin zone becomes <code>[0,1]^d</code>, and integrands should have this periodicity. If the integrand depends on the Brillouin zone basis, then it may have to be transformed to the Cartesian coordinates as a post-processing step. These algorithms also use the symmetries of the Brillouin zone and the integrand.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/27d1a4e3e828093609c9ed189a2de006f33bc85d/src/brillouin.jl#L289-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.IAI" href="#AutoBZCore.IAI"><code>AutoBZCore.IAI</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IAI(alg::IntegralAlgorithm=AuxQuadGKJL())
IAI(algs::IntegralAlgorithm...)</code></pre><p>Iterated-adaptive integration using <code>nested_quad</code> from <a href="https://github.com/lxvm/IteratedIntegration.jl">IteratedIntegration.jl</a>. <strong>This algorithm is the most efficient for localized integrands</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/27d1a4e3e828093609c9ed189a2de006f33bc85d/src/brillouin.jl#L400-L407">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.TAI" href="#AutoBZCore.TAI"><code>AutoBZCore.TAI</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TAI(; norm=norm, initdivs=1)</code></pre><p>Tree-adaptive integration using <code>hcubature</code> from <a href="https://github.com/JuliaMath/HCubature.jl">HCubature.jl</a>. This routine is limited to integration over hypercube domains and may not use all symmetries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/27d1a4e3e828093609c9ed189a2de006f33bc85d/src/brillouin.jl#L497-L503">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.PTR" href="#AutoBZCore.PTR"><code>AutoBZCore.PTR</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PTR(; npt=50, nthreads=1)</code></pre><p>Periodic trapezoidal rule with a fixed number of k-points per dimension, <code>npt</code>, using the routine <code>ptr</code> from <a href="https://github.com/lxvm/AutoSymPTR.jl">AutoSymPTR.jl</a>. <strong>The caller should check that the integral is converged w.r.t. <code>npt</code></strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/27d1a4e3e828093609c9ed189a2de006f33bc85d/src/brillouin.jl#L420-L426">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.AutoPTR" href="#AutoBZCore.AutoPTR"><code>AutoBZCore.AutoPTR</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AutoPTR(; norm=norm, a=1.0, nmin=50, nmax=1000, n₀=6, Δn=log(10), keepmost=2, nthreads=1)</code></pre><p>Periodic trapezoidal rule with automatic convergence to tolerances passed to the solver with respect to <code>norm</code> using the routine <code>autosymptr</code> from <a href="https://github.com/lxvm/AutoSymPTR.jl">AutoSymPTR.jl</a>. <strong>This algorithm is the most efficient for smooth integrands</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/27d1a4e3e828093609c9ed189a2de006f33bc85d/src/brillouin.jl#L438-L445">source</a></section></article><h2 id="DOSProblem-algorithms"><a class="docs-heading-anchor" href="#DOSProblem-algorithms"><code>DOSProblem</code> algorithms</a><a id="DOSProblem-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#DOSProblem-algorithms" title="Permalink"></a></h2><p>Currently the available algorithms are an initial release and we would like to include the following reference algorithms that are also common in the literature in a future release:</p><ul><li>(Linear) Tetrahedron Method</li><li>Adaptive Gaussian broadening</li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.DOSAlgorithm" href="#AutoBZCore.DOSAlgorithm"><code>AutoBZCore.DOSAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DOSAlgorithm</code></pre><p>Abstract supertype for algorithms for computing density of states</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/27d1a4e3e828093609c9ed189a2de006f33bc85d/src/dos_interfaces.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.GGR" href="#AutoBZCore.GGR"><code>AutoBZCore.GGR</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GGR(; npt=50)</code></pre><p>Generalized Gilat-Raubenheimer method as in <a href="https://doi.org/10.1088/2040-8986/aaae52">&quot;Generalized Gilat–Raubenheimer method for density-of-states calculation in photonic crystals&quot;</a>. This method requires the Hamiltonian and its derivatives, and performs a linear extrapolation at each k-point in an equispace grid. The algorithm is expected to show second-order convergence and suffer reduced error at band crossings compared to interpolatory methods.</p><p><strong>Arguments</strong></p><ul><li><code>npt</code>: the number of k-points per dimension</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/27d1a4e3e828093609c9ed189a2de006f33bc85d/src/dos_algorithms.jl#L9-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZCore.ImplicitIntegrationJL" href="#AutoBZCore.ImplicitIntegrationJL"><code>AutoBZCore.ImplicitIntegrationJL</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ImplicitIntegrationJL(; kws...)</code></pre><p>This algorithm is implemented in an extension. Try it with <code>using ImplicitIntegration</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/27d1a4e3e828093609c9ed189a2de006f33bc85d/src/dos_algorithms.jl#L29-L33">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../integrands/">« Integrands</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Thursday 7 November 2024 13:29">Thursday 7 November 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
