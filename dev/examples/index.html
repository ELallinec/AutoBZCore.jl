<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · AutoBZCore.jl</title><meta name="title" content="Examples · AutoBZCore.jl"/><meta property="og:title" content="Examples · AutoBZCore.jl"/><meta property="twitter:title" content="Examples · AutoBZCore.jl"/><meta name="description" content="Documentation for AutoBZCore.jl."/><meta property="og:description" content="Documentation for AutoBZCore.jl."/><meta property="twitter:description" content="Documentation for AutoBZCore.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AutoBZCore.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Green&#39;s-function-integration"><span>Green&#39;s function integration</span></a></li><li><a class="tocitem" href="#BZ-integration"><span>BZ integration</span></a></li><li><a class="tocitem" href="#Density-of-States"><span>Density of States</span></a></li></ul></li><li><a class="tocitem" href="../problems/">Problems</a></li><li><a class="tocitem" href="../integrands/">Integrands</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li><li><a class="tocitem" href="../reference/">Reference</a></li><li><a class="tocitem" href="../extensions/">Extensions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/lxvm/AutoBZCore.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/lxvm/AutoBZCore.jl/blob/main/docs/src/examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><p>The following are several examples of how to use the algorithms and integrands provided by AutoBZCore.jl. For background on the essential interface see the <a href="../problems/#Problem-definitions">Problem definitions</a> page</p><h2 id="Green&#39;s-function-integration"><a class="docs-heading-anchor" href="#Green&#39;s-function-integration">Green&#39;s function integration</a><a id="Green&#39;s-function-integration-1"></a><a class="docs-heading-anchor-permalink" href="#Green&#39;s-function-integration" title="Permalink"></a></h2><p>A common integral appearing in <a href="https://en.wikipedia.org/wiki/Dynamical_mean-field_theory">Dynamical mean-field theory</a> is that of the local Green&#39;s function:</p><p class="math-container">\[G(\omega) = \int d^d \vec{k}\ \operatorname{Tr} \left[ \left( \omega - H \left( \vec{k} \right) - \Sigma(\omega) \right)^{-1} \right].\]</p><p>For simplicity, we take <span>$\Sigma(\omega) = -i\eta$</span>. We can define the integrand as a function of <span>$\vec{k}$</span> and <span>$H$</span> and parameters <span>$\eta, \omega$</span>.</p><pre><code class="language-julia hljs">using LinearAlgebra
gloc_integrand(k, (; h, η, ω)) = tr(inv(complex(ω,η)*I-h(k)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">gloc_integrand (generic function with 1 method)</code></pre><p>Here we use named tuple destructuring syntax to unpack a named tuple of parameters in the function definition.</p><p>Commonly, <span>$H(\vec{k})$</span> is evaluated using Wannier interpolation, i.e. as a Fourier series. For a simple tight-binding model, the integer lattice, the Hamiltonian is given by</p><p class="math-container">\[H(k) = \cos(2\pi k) = \frac{1}{2} \left( e^{2\pi ik} + e^{-2\pi ik} \right)\]</p><p>We can use the built-in function <code>cos</code> to evaluate this, however, for more complex Fourier series it becomes easier to use the representation in terms of Fourier coefficients. Using the package <a href="https://github.com/lxvm/FourierSeriesEvaluators.jl">FourierSeriesEvaluators.jl</a>, we can define <span>$H(k) = \cos(2\pi k)$</span> by the following:</p><pre><code class="language-julia hljs">using FourierSeriesEvaluators
h = FourierSeries([0.5, 0.0, 0.5]; period=1, offset=-2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element and (1,)-periodic FourierSeries with Float64 coefficients, (0,) derivative, (-2,) offset</code></pre><p>The coefficient values of <span>$1/2$</span> can be determined from Euler&#39;s formula, as used in the expansion of <span>$\cos$</span> above, and the value of <code>offset</code> is chosen to offset the coefficient array indices, <code>1:3</code> since Julia has 1-based indexing, to correspond to values of <span>$n$</span> in the phase factors <span>$e^{2\pi i n k}$</span> used in the Fourier series above, i.e. <code>-1:1</code>. Now we proceed to the define the <a href="../problems/#AutoBZCore.IntegralProblem"><code>IntegralProblem</code></a> and solve it with a generic adaptive integration scheme, <a href="../algorithms/#AutoBZCore.QuadGKJL"><code>QuadGKJL</code></a></p><pre><code class="language-julia hljs">using AutoBZCore
dom = (0, 1)
p = (; h, η=0.1, ω=0.0)
prob = IntegralProblem(gloc_integrand, dom, p)
alg = QuadGKJL()
solve(prob, alg; abstol=1e-3).value</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-2.7755575615628914e-17 - 0.9950375451895513im</code></pre><h2 id="BZ-integration"><a class="docs-heading-anchor" href="#BZ-integration">BZ integration</a><a id="BZ-integration-1"></a><a class="docs-heading-anchor-permalink" href="#BZ-integration" title="Permalink"></a></h2><p>To perform integration over a Brillouin zone, we can load one using the <a href="../reference/#AutoBZCore.load_bz"><code>load_bz</code></a> function and then construct an <a href="../problems/#AutoBZCore.AutoBZProblem"><code>AutoBZProblem</code></a> to solve. Since the Brillouin zone may be reduced using point group symmetries, a common optimization, it is also required to specify the symmetry representation of the integrand. Continuing the previous example, the trace of the Green&#39;s function has no band/orbital degrees of freedom and transforms trivially under the point group, so it is a <a href="../reference/#AutoBZCore.TrivialRep"><code>TrivialRep</code></a>. The previous calculation can be replicated as:</p><pre><code class="language-julia hljs">using AutoBZCore
bz = load_bz(FBZ(), 2pi*I(1))
p = (; h, η=0.1, ω=0.0)
prob = AutoBZProblem(TrivialRep(), IntegralFunction(gloc_integrand), bz, p)
alg = TAI()
solve(prob, alg; abstol=1e-3).value</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.3877787807814457e-17 - 0.9950375451895511im</code></pre><p>Now we proceed to multi-dimensional integrals. In this case, Wannier interpolation is much more efficient when Fourier series are evaluated one variable at a time. To understand, this suppose we have a series defined by <span>$M \times M$</span> coefficients (i.e. a 2d series) that we want to evaluate on an <span>$N \times N$</span> grid. Naively evaluating the series at each grid point will require <span>$\mathcal{O}(M^{2} N^{2})$</span> operations, however, we can reduce the complexity by pre-evaluating certain coefficients as follows</p><p class="math-container">\[f(x, y) = \sum_{m,n=1}^{M} f_{nm} e^{i(nx + my)} = \sum_{n=1}^{M} e^{inx} \left( \sum_{m=1}^{M} f_{nm} e^{imy} \right) = \sum_{n=1}^{M} e^{inx} \tilde{f}_{n}(y)\]</p><p>This means we can evaluate the series on the grid in <span>$\mathcal{O}(M N^2 + M^2 N)$</span> operations. When <span>$N \gg M$</span>, this is <span>$\mathcal{O}(M N^{2})$</span> operations, which is comparable to the computational complexity of a <a href="https://en.wikipedia.org/wiki/Fast_Fourier_transform#Multidimensional_FFTs">multi-dimensional FFT</a>. Since the constants of a FFT may not be trivial, this scheme is competitive.</p><p>Let&#39;s use this with a Fourier series corresponding to <span>$H(\vec{k}) = \cos(2\pi k_{x}) + \cos(2\pi k_{y})$</span> and define a new method of <code>gloc_integrand</code> that accepts the (efficiently) evaluated Fourier series in the second argument</p><pre><code class="language-julia hljs">h = FourierSeries([0.0; 0.5; 0.0;; 0.5; 0.0; 0.5;; 0.0; 0.5; 0.0]; period=1, offset=-2)
gloc_integrand(k, h_k, (; η, ω)) = tr(inv(complex(ω,η)*I-h_k))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">gloc_integrand (generic function with 2 methods)</code></pre><p>Similar to before, we construct an <a href="../problems/#AutoBZCore.IntegralProblem"><code>AutoBZCore.IntegralProblem</code></a> and this time we take the integration domain to correspond to the full Brillouin zone of a square lattice with lattice vectors <code>2pi*I(2)</code>.</p><pre><code class="language-julia hljs">integrand = FourierIntegralFunction(gloc_integrand, h)
bz = load_bz(FBZ(2), 2pi*I(2))
p = (; η=0.1, ω=0.0)
prob = AutoBZProblem(TrivialRep(), integrand, bz, p)
alg = IAI()
solve(prob, alg).value</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.48318857196017e-16 - 1.3941704645339517im</code></pre><p>This package provides several <a href="../algorithms/#AutoBZProblem-algorithms"><code>AutoBZProblem</code> algorithms</a> that we can use to solve the multidimensional integral.</p><p>The <a href="https://github.com/lxvm/AutoBZCore.jl/tree/main/aps_example">repo&#39;s demo</a> on density of states provides a complete example of how to compute and interpolate an integral as a function of its parameters using the <a href="../problems/#init-and-solve!"><code>init</code> and <code>solve!</code></a> interface</p><h2 id="Density-of-States"><a class="docs-heading-anchor" href="#Density-of-States">Density of States</a><a id="Density-of-States-1"></a><a class="docs-heading-anchor-permalink" href="#Density-of-States" title="Permalink"></a></h2><p>Computing the density of states (DOS) of a self-adjoint, or Hermitian, operator is a related, but distinct problem to the integrals also presented in this package. In fact, many DOS algorithms will compute integrals to approximate the DOS of an operator by introducing an artificial broadening. To handle the <span>$T=0^{+}$</span> limit of the broadening, we implement the well-known <a href="https://arxiv.org/abs/1711.07993">Gilat-Raubenheimer method</a> as an algorithm for the <a href="../problems/#AutoBZCore.DOSProblem"><code>AutoBZCore.DOSProblem</code></a></p><p>Using the <a href="../problems/#CommonSolve.init"><code>AutoBZCore.init</code></a> and <a href="../problems/#CommonSolve.solve!"><code>AutoBZCore.solve!</code></a> functions, it is possible to construct a cache to solve a <a href="../problems/#AutoBZCore.DOSProblem"><code>DOSProblem</code></a> for several energies or several Hamiltonians. As an example of solving for several energies,</p><pre><code class="language-julia hljs">using AutoBZCore, FourierSeriesEvaluators, StaticArrays
h = FourierSeries(SMatrix{1,1,Float64,1}.([0.5, 0.0, 0.5]), period=1.0, offset=-2)
E = 0.3
bz = load_bz(FBZ(), [2pi;;])
prob = DOSProblem(h, E, bz)
alg = GGR(; npt=100)
cache = init(prob, alg)
Es = range(-1, 1, length=10) * 1.1
data = map(Es) do E
    cache.domain = E
    solve!(cache).value
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element Vector{Float64}:
 0.0
 0.5940536926606439
 0.3934526572333864
 0.34235097468581055
 0.3208398038674902
 0.32083980386749017
 0.34235097468581066
 0.3934526572333864
 0.5940536926606439
 0.0</code></pre><p>As an example of interchanging Hamiltonians, which must remain the same type, we can double the energies, which will halve the DOS</p><pre><code class="language-julia hljs">cache.domain = E
sol1 = AutoBZCore.solve!(cache)

h.c .*= 2
cache.isfresh = true
cache.domain = 2E

sol2 = AutoBZCore.solve!(cache)

sol1.value ≈ 2sol2.value</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../problems/">Problems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Thursday 7 November 2024 13:29">Thursday 7 November 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
