<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Integration · AutoBZCore.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AutoBZCore.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Integration</a><ul class="internal"><li><a class="tocitem" href="#Parametrizing-integrals"><span>Parametrizing integrals</span></a></li><li><a class="tocitem" href="#Integrands"><span>Integrands</span></a></li><li><a class="tocitem" href="#Algorithms"><span>Algorithms</span></a></li></ul></li><li><a class="tocitem" href="../bz/">Brillouin zones</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Integration</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Integration</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lxvm/AutoBZCore.jl/blob/main/docs/src/integration.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Integration"><a class="docs-heading-anchor" href="#Integration">Integration</a><a id="Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Integration" title="Permalink"></a></h1><p>The integration tools provided by AutoBZCore.jl are very flexible and allow for many kinds of user-defined integrals with specialized behaviors. Examples implementations can be found in AutoBZ.jl.</p><h2 id="Parametrizing-integrals"><a class="docs-heading-anchor" href="#Parametrizing-integrals">Parametrizing integrals</a><a id="Parametrizing-integrals-1"></a><a class="docs-heading-anchor-permalink" href="#Parametrizing-integrals" title="Permalink"></a></h2><p><a href="https://docs.sciml.ai/Integrals/stable/">Integrals.jl</a> provides a generic and unified interface for computing integrals that works well for all kinds of problems. This package builds on that interface by offering <a href="#AutoBZCore.IntegralSolver"><code>IntegralSolver</code></a>s to easily parametrize an integral for a given integrand, limits of integration, algorithm, and error tolerances. Until the SciML community arrives at a <a href="https://github.com/SciML/DifferentialEquations.jl/issues/881">consensus</a> of what a parametrization interface looks like, this gets the job done.</p><article class="docstring"><header><a class="docstring-binding" id="AutoBZCore.IntegralSolver" href="#AutoBZCore.IntegralSolver"><code>AutoBZCore.IntegralSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntegralSolver(f, lb, ub, alg; abstol=0, reltol=sqrt(eps()), maxiters=typemax(Int))
IntegralSolver(f, bz::SymmetricBZ, alg::AbstractAutoBZAlgorithm; kwargs...)</code></pre><p>Constructs a functor that solves an integral of <code>f</code> over the given domain (e.g. <code>lb</code> to <code>ub</code> or a <code>bz</code>) using the given <code>alg</code> to within the given tolerances. Calling this functor, <code>fun</code> with parameters <code>p</code> using the syntax <code>fun(p)</code> returns the estimated integral <code>I</code>. Under the hood, this uses the <a href="https://docs.sciml.ai/Integrals/stable/">Integrals.jl interface</a> for defining an <code>IntegralProblem</code>, so <code>f</code> must be a 2-argument function <code>f(x,p)</code>, or if in-place, a 3-argument function <code>f(y,x,p)</code>.</p><p>Also, the types <a href="#AutoBZCore.Integrand"><code>Integrand</code></a> and <a href="#AutoBZCore.FourierIntegrand"><code>FourierIntegrand</code></a> allow for providing a partial set of parameters so that the <code>IntegralSolver</code> can interface easily with other algorithms, such as root-finding and interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/4711eb4a4bcd250df31694a3c8b578040bbee0f4/src/solver.jl#L1-L16">source</a></section></article><h2 id="Integrands"><a class="docs-heading-anchor" href="#Integrands">Integrands</a><a id="Integrands-1"></a><a class="docs-heading-anchor-permalink" href="#Integrands" title="Permalink"></a></h2><p>User-defined integrands should be able to take any number of parameters and should be entirely general. We only require that the integrand functions take only positional arguments.</p><p>The integrand types below solve the problem of providing the integrand evaluator parameters a partial set of parameters so that the <a href="#AutoBZCore.IntegralSolver"><code>IntegralSolver</code></a> can parametrize the remaining ones. Namely, the full set of parameters is the union of the ones included in the integrand follow by those passed to the solver, therefore <strong>the caller is responsible for ensuring that the ordered union of parameters they pass to the integrand and solver matches the positional arguments of their integrand evaluator</strong>. Note that this behavior slightly differs from using the SciML routine <code>remake</code> for an <code>IntegralProblem</code>.</p><article class="docstring"><header><a class="docstring-binding" id="AutoBZCore.Integrand" href="#AutoBZCore.Integrand"><code>AutoBZCore.Integrand</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Integrand(f, p...)</code></pre><p>Represent an integrand with a partial collection of parameters <code>p</code>. When the <code>Integrand</code> is invoked with one argument, e.g. <code>int(x)</code>, it evaluates <code>f(x, p...)</code>. However when invoked with two arguments, as in an <code>IntegralProblem</code>, e.g. <code>int(x, p2)</code>, it evaluates the union of parameters <code>f(x, p..., p2...)</code>. This allows for convenient parametrization of the integrand.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/4711eb4a4bcd250df31694a3c8b578040bbee0f4/src/integrand.jl#L2-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZCore.FourierIntegrand" href="#AutoBZCore.FourierIntegrand"><code>AutoBZCore.FourierIntegrand</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FourierIntegrand(f, s::AbstractFourierSeries, p...)</code></pre><p>A type generically representing an integrand <code>f</code> whose entire dependence on the variables of integration is in a Fourier series <code>s</code>, and which may also accept some input parameters <code>p</code>. The caller must know that their function, <code>f</code>, will be evaluated at many points, <code>x</code>, in the following way: <code>f(s(x), p...)</code>. Therefore the caller is expected to know the type of <code>s(x)</code> and the layout of the parameters in the tuple <code>p</code> (hint: it should correspond to the arguments of the function). This type is optimized for the IAI and PTR routines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/4711eb4a4bcd250df31694a3c8b578040bbee0f4/src/fourier_integration.jl#L1-L11">source</a></section></article><h2 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h2><p>There are many Brillouin zone integration algorithms, but the ones provided by this package work for black-box integrands and converge automatically to a requested tolerance, except where noted. Additionally, the algorithms are fully compatible with integration over the IBZ, except where noted. More details on the algorithms can be found from their respective packages.</p><article class="docstring"><header><a class="docstring-binding" id="AutoBZCore.AbstractAutoBZAlgorithm" href="#AutoBZCore.AbstractAutoBZAlgorithm"><code>AutoBZCore.AbstractAutoBZAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractAutoBZAlgorithm</code></pre><p>Abstract supertype for Brillouin zone integration algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/4711eb4a4bcd250df31694a3c8b578040bbee0f4/src/algorithms.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZCore.IAI" href="#AutoBZCore.IAI"><code>AutoBZCore.IAI</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IAI(; order=7, norm=norm, initdivs=nothing, segbufs=nothing)</code></pre><p>Iterated-adaptive integration using <code>nested_quadgk</code> from <a href="https://github.com/lxvm/IteratedIntegration.jl">IteratedIntegration.jl</a>. <strong>This algorithm is the most efficient for localized integrands</strong>. See <a href="#IteratedIntegration.alloc_segbufs"><code>alloc_segbufs</code></a> for how to pre-allocate segment buffers for <code>nested_quadgk</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/4711eb4a4bcd250df31694a3c8b578040bbee0f4/src/algorithms.jl#L8-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZCore.PTR" href="#AutoBZCore.PTR"><code>AutoBZCore.PTR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PTR(; npt=50, rule=nothing)</code></pre><p>Periodic trapezoidal rule with a fixed number of k-points per dimension, <code>npt</code>, using the routine <code>ptr</code> from <a href="https://github.com/lxvm/AutoSymPTR.jl">AutoSymPTR.jl</a>. <strong>The caller should check that the integral is converged w.r.t. <code>npt</code></strong>. See <a href="#AutoBZCore.alloc_rule"><code>alloc_rule</code></a> for how to pre-evaluate a PTR rule for use across calls with compatible integrands.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/4711eb4a4bcd250df31694a3c8b578040bbee0f4/src/algorithms.jl#L25-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZCore.AutoPTR" href="#AutoBZCore.AutoPTR"><code>AutoBZCore.AutoPTR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AutoPTR(; norm=norm, buffer=nothing)</code></pre><p>Periodic trapezoidal rule with automatic convergence to tolerances passed to the solver with respect to <code>norm</code> using the routine <code>autosymptr</code> from <a href="https://github.com/lxvm/AutoSymPTR.jl">AutoSymPTR.jl</a>. <strong>This algorithm is the most efficient for smooth integrands</strong>. See <a href="#AutoSymPTR.alloc_autobuffer"><code>alloc_autobuffer</code></a> for how to pre-evaluate a buffer for <code>autosymptr</code> for use across calls with compatible integrands.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/4711eb4a4bcd250df31694a3c8b578040bbee0f4/src/algorithms.jl#L40-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZCore.PTR_IAI" href="#AutoBZCore.PTR_IAI"><code>AutoBZCore.PTR_IAI</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PTR_IAI(; ptr=PTR(), iai=IAI())</code></pre><p>Multi-algorithm that returns an <code>IAI</code> calculation with an <code>abstol</code> determined from the given <code>reltol</code> and a <code>PTR</code> estimate, <code>I</code>, as <code>reltol*norm(I)</code>. This addresses the issue that <code>IAI</code> does not currently use a globally-adaptive algorithm and may not have the expected scaling with localization length unless an <code>abstol</code> is used since computational effort may be wasted via a <code>reltol</code> with the naive <code>nested_quadgk</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/4711eb4a4bcd250df31694a3c8b578040bbee0f4/src/algorithms.jl#L56-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZCore.AutoPTR_IAI" href="#AutoBZCore.AutoPTR_IAI"><code>AutoBZCore.AutoPTR_IAI</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AutoPTR_IAI(; reltol=1.0, ptr=AutoPTR(), iai=IAI())</code></pre><p>Multi-algorithm that returns an <code>IAI</code> calculation with an <code>abstol</code> determined from an <code>AutoPTR</code> estimate, <code>I</code>, computed to <code>reltol</code> precision, and the <code>rtol</code> given to the solver as <code>rtol*norm(I)</code>. This addresses the issue that <code>IAI</code> does not currently use a globally-adaptive algorithm and may not have the expected scaling with localization length unless an <code>abstol</code> is used since computational effort may be wasted via a <code>reltol</code> with the naive <code>nested_quadgk</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/4711eb4a4bcd250df31694a3c8b578040bbee0f4/src/algorithms.jl#L72-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZCore.TAI" href="#AutoBZCore.TAI"><code>AutoBZCore.TAI</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TAI(; rule=HCubatureJL())</code></pre><p>Tree-adaptive integration using <code>hcubature</code> from <a href="https://github.com/JuliaMath/HCubature.jl">HCubature.jl</a>. This routine is limited to integration over hypercube domains and may not use all symmetries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/4711eb4a4bcd250df31694a3c8b578040bbee0f4/src/algorithms.jl#L91-L97">source</a></section></article><h3 id="Allocations-for-algorithms"><a class="docs-heading-anchor" href="#Allocations-for-algorithms">Allocations for algorithms</a><a id="Allocations-for-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Allocations-for-algorithms" title="Permalink"></a></h3><p>In practice, allocating memory for an algorithm can help improve its performance. This is particularly noticeable for PTR, where one of the main optimizations is to store the Fourier series evaluated on the PTR grid for reuse across multiple compatible calls. The routines below show how to pre-evaluate or pre-allocate the memory necessary for different algorithms.</p><article class="docstring"><header><a class="docstring-binding" id="AutoBZCore.alloc_rule" href="#AutoBZCore.alloc_rule"><code>AutoBZCore.alloc_rule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">alloc_rule(f::AbstractFourierSeries, ::Type, syms)</code></pre><p>Compute the values of <code>f</code> on the PTR grid as well as the quadrature weights for the given <code>syms</code> to use across multiple compatible calls of the <a href="#AutoBZCore.PTR"><code>PTR</code></a> algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/4711eb4a4bcd250df31694a3c8b578040bbee0f4/src/fourier_integration.jl#L209-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoSymPTR.alloc_autobuffer" href="#AutoSymPTR.alloc_autobuffer"><code>AutoSymPTR.alloc_autobuffer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">alloc_autobuffer(f::AbstractFourierSeries, ::Type, syms)</code></pre><p>Initialize an empty buffer of PTR rules with pre-evaluated Fourier series evaluated on a domain of type <code>T</code> with symmetries <code>syms</code> to use across multiple compatible calls of the <a href="#AutoBZCore.AutoPTR"><code>AutoPTR</code></a> algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/4711eb4a4bcd250df31694a3c8b578040bbee0f4/src/fourier_integration.jl#L220-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IteratedIntegration.alloc_segbufs" href="#IteratedIntegration.alloc_segbufs"><code>IteratedIntegration.alloc_segbufs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">alloc_segbufs(coefficient_type, range_type, norm_type, ndim)</code></pre><p>Allocate a segment buffer for multiple compatible calls to <a href="#AutoBZCore.IAI"><code>IAI</code></a>. Typically <code>coefficient_type</code> would be <code>eltype(bz)</code>, <code>range_type</code> would be the return type of the integrand, and <code>norm_type</code> would be <code>Base.promote_op(norm, range_type)</code>. <code>ndim</code> should be the number of dimensions of integration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/4711eb4a4bcd250df31694a3c8b578040bbee0f4/src/fourier_integration.jl#L232-L239">source</a></section></article><h3 id="Parallelization"><a class="docs-heading-anchor" href="#Parallelization">Parallelization</a><a id="Parallelization-1"></a><a class="docs-heading-anchor-permalink" href="#Parallelization" title="Permalink"></a></h3><p>This package parallelizes <span>$k$</span>-sums in the <a href="#AutoBZCore.PTR"><code>PTR</code></a> and <a href="#AutoBZCore.AutoPTR"><code>AutoPTR</code></a> routines by default, which gives good multi-threaded performance for those algorithms when the number of <span>$k$</span>-points is large. On the other hand, if the number of parameter points for which you would like to evaluate an integral is large, then parameter-parallelization is an effective strategy and done by the routines below.</p><article class="docstring"><header><a class="docstring-binding" id="AutoBZCore.batchsolve" href="#AutoBZCore.batchsolve"><code>AutoBZCore.batchsolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">batchsolve(f, ps, [T=Base.promote_op(f, eltype(ps))]; nthreads=Threads.nthreads())</code></pre><p>Evaluate the <a href="#AutoBZCore.IntegralSolver"><code>IntegralSolver</code></a> <code>f</code> at each of the parameters <code>ps</code> in parallel. Returns a vector containing the evaluated integrals <code>I</code>. This is a form of multithreaded broadcasting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/4711eb4a4bcd250df31694a3c8b578040bbee0f4/src/solver.jl#L91-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZCore.batchparam" href="#AutoBZCore.batchparam"><code>AutoBZCore.batchparam</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">batchparam(ps, nthreads)</code></pre><p>If the cost of a calculation smoothly varies with the parameters <code>ps</code>, then batch <code>ps</code> into <code>nthreads</code> groups where the <code>i</code>th element of group <code>j</code> is <code>ps[j+(i-1)*nthreads]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZCore.jl/blob/4711eb4a4bcd250df31694a3c8b578040bbee0f4/src/solver.jl#L57-L63">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../bz/">Brillouin zones »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 14 March 2023 15:37">Tuesday 14 March 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
