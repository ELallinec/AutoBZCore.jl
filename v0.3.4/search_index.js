var documenterSearchIndex = {"docs":
[{"location":"extensions/#Package-extensions","page":"Extensions","title":"Package extensions","text":"","category":"section"},{"location":"extensions/#SymmetryReduceBZ.jl","page":"Extensions","title":"SymmetryReduceBZ.jl","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Loading SymmetryReduceBZ.jl provides a specialized method of load_bz that when provided atom species and positions can compute the IBZ.","category":"page"},{"location":"extensions/#HDF5.jl","page":"Extensions","title":"HDF5.jl","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Loading HDF5.jl provides a specialized method of batchsolve that accepts an H5 archive or group in the first argument and writes the integral results and timings to a dataset.","category":"page"},{"location":"extensions/#WannierIO.jl","page":"Extensions","title":"WannierIO.jl","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Loading WannierIO.jl provides a specialized method of load_bz that loads the BZ defined in a seedname.wout file.","category":"page"},{"location":"extensions/#AtomsBase.jl","page":"Extensions","title":"AtomsBase.jl","text":"","category":"section"},{"location":"extensions/","page":"Extensions","title":"Extensions","text":"Loading AtomsBase.jl provides a specialized method of load_bz to load the BZ of an AtomsBase.AbstractSystem","category":"page"},{"location":"integrands/#Integrands","page":"Integrands","title":"Integrands","text":"","category":"section"},{"location":"integrands/","page":"Integrands","title":"Integrands","text":"The design of AutoBZCore.jl uses multiple dispatch to provide multiple interfaces for user integrands that allow various optimizations to be compatible with a common interface for solvers. Unfortunately, not all algorithms support all integrands, since the underlying libraries must support the same interface.","category":"page"},{"location":"integrands/#Functions","page":"Integrands","title":"Functions","text":"","category":"section"},{"location":"integrands/","page":"Integrands","title":"Integrands","text":"A user can pass an integrand of the form f(x,p) in the same way as in Integrals.jl","category":"page"},{"location":"integrands/#ParameterIntegrand","page":"Integrands","title":"ParameterIntegrand","text":"","category":"section"},{"location":"integrands/","page":"Integrands","title":"Integrands","text":"AutoBZCore.ParameterIntegrand","category":"page"},{"location":"integrands/#AutoBZCore.ParameterIntegrand","page":"Integrands","title":"AutoBZCore.ParameterIntegrand","text":"ParameterIntegrand(f, args...; kwargs...)\n\nRepresent an integrand with a partial collection of parameters p. When the ParameterIntegrand is invoked with one argument, e.g. int(x), it evaluates f(x, p...; kwargs...). However when invoked with two arguments, as in an IntegralProblem, e.g. int(x, p2), it evaluates the union of parameters f(x, p..., p2...; kwargs...). This allows for convenient parametrization of the integrand.\n\n\n\n\n\n","category":"type"},{"location":"integrands/#InplaceIntegrand","page":"Integrands","title":"InplaceIntegrand","text":"","category":"section"},{"location":"integrands/","page":"Integrands","title":"Integrands","text":"AutoBZCore.InplaceIntegrand","category":"page"},{"location":"integrands/#AutoBZCore.InplaceIntegrand","page":"Integrands","title":"AutoBZCore.InplaceIntegrand","text":"InplaceIntegrand(f!, result::AbstractArray)\n\nConstructor for a InplaceIntegrand accepting an integrand of the form f!(y,x,p). The caller also provides an output array needed to store the result of the quadrature. Intermediate y arrays are allocated during the calculation, and the final result is may or may not be written to result, so use the IntegralSolution immediately after the calculation to read the result, and don't expect it to persist if the same integrand is used for another calculation.\n\n\n\n\n\n","category":"type"},{"location":"integrands/#BatchIntegrand","page":"Integrands","title":"BatchIntegrand","text":"","category":"section"},{"location":"integrands/","page":"Integrands","title":"Integrands","text":"AutoBZCore.BatchIntegrand","category":"page"},{"location":"integrands/#AutoBZCore.BatchIntegrand","page":"Integrands","title":"AutoBZCore.BatchIntegrand","text":"BatchIntegrand(f!, y::AbstractArray, x::AbstractVector, max_batch=typemax(Int))\n\nConstructor for a BatchIntegrand accepting an integrand of the form f!(y,x,p) = y .= f!.(x, Ref(p)) that can evaluate the integrand at multiple quadrature nodes using, for example, threads, the GPU, or distributed-memory. The max_batch keyword is a soft limit on the number of nodes passed to the integrand. The buffers y,x must both be resize!-able since the number of evaluation points may vary between calls to f!.\n\n\n\n\n\n","category":"type"},{"location":"integrands/#FourierIntegrand","page":"Integrands","title":"FourierIntegrand","text":"","category":"section"},{"location":"integrands/","page":"Integrands","title":"Integrands","text":"AutoBZCore.FourierIntegrand","category":"page"},{"location":"integrands/#AutoBZCore.FourierIntegrand","page":"Integrands","title":"AutoBZCore.FourierIntegrand","text":"FourierIntegrand(f, w::FourierWorkspace, args...; kws...)\n\nConstructs an integrand of the form f(FourierValue(x,w(x)), args...; kws...) where the Fourier series in w is evaluated efficiently, i.e. one dimension at a time, with compatible algorithms. f should accept parameters as arguments and keywords, similar to a ParameterIntegrand although the first argument to f will always be a FourierValue.\n\n\n\n\n\nFourierIntegrand(f, s::AbstractFourierSeries, args...; kws...)\n\nOuter constructor for FourierIntegrand that wraps the Fourier series s into a single-threaded FourierWorkspace.\n\n\n\n\n\n","category":"type"},{"location":"integrands/#NestedBatchIntegrand","page":"Integrands","title":"NestedBatchIntegrand","text":"","category":"section"},{"location":"integrands/","page":"Integrands","title":"Integrands","text":"AutoBZCore.NestedBatchIntegrand","category":"page"},{"location":"integrands/#AutoBZCore.NestedBatchIntegrand","page":"Integrands","title":"AutoBZCore.NestedBatchIntegrand","text":"NestedBatchIntegrand(f::Tuple, y::AbstractVector, x::AbstractVector, max_batch::Integer)\n\nAn integrand type intended for multi-threaded evaluation of NestedQuad. The caller provides a tuple f of worker functions that can evaluate the same integrand on different threads, so as to avoid race conditions. These workers can also be NestedBatchIntegrands depending on if the user wants to parallelize the integration at multiple levels of nesting. The other arguments are the same as for BatchIntegrand.\n\n\n\n\n\n","category":"type"},{"location":"problems/#Problem-definitions","page":"Problems","title":"Problem definitions","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"The design of AutoBZCore.jl is heavily influenced by the SciML package Integrals.jl and may eventually become implemented in it.","category":"page"},{"location":"problems/#SciML-interface","page":"Problems","title":"SciML interface","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"AutoBZCore.jl replicates the Integrals.jl interface, but does not export it in order to avoid name conflicts with other SciML packages.","category":"page"},{"location":"problems/#Quickstart","page":"Problems","title":"Quickstart","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"using AutoBZCore: IntegralProblem, init, solve!\n\nprob = IntegralProblem((x,p) -> sin(p*x), 0, 1, 0.3)\ncache = init(prob, QuadGKJL())\nsolve!(cache)   # 0.14887836958131329\n\n# solve again at a new parameter\ncache.p = 0.4\nsolve!(cache)   # 0.1973475149927873","category":"page"},{"location":"problems/#Reference","page":"Problems","title":"Reference","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"AutoBZCore.IntegralProblem\nAutoBZCore.solve\nAutoBZCore.init\nAutoBZCore.solve!\nAutoBZCore.NullParameters","category":"page"},{"location":"problems/#AutoBZCore.IntegralProblem","page":"Problems","title":"AutoBZCore.IntegralProblem","text":"IntegralProblem(f, domain, [p=NullParameters])\nIntegralProblem(f, a::T, b::T, [p=NullParameters]) where {T}\n\nCollects the data need to define an integral of a function f(x, p) over a domain containing the points, x, and set with parameters p (default: NullParameters). If the domain is an interval or hypercube, it can also be specified by its endpoints a, b, and it gets converted to a PuncturedInterval or HyperCube.\n\n\n\n\n\n","category":"type"},{"location":"problems/#AutoBZCore.solve","page":"Problems","title":"AutoBZCore.solve","text":"solve(::IntegralProblem, ::IntegralAlgorithm; kws...)::IntegralSolution\n\nCompute the solution to the given IntegralProblem using the given IntegralAlgorithm for the given keyword arguments to the solver (i.e. abstol, reltol, or maxiters).\n\nKeywords\n\nabstol: an absolute error tolerance to get the solution to a specified number of absolute digits, e.g. 1e-3 requests accuracy to 3 decimal places.  Note that this number must have the same units as the integral. (default: nothing)\nreltol: a relative error tolerance equivalent to specifying a number of significant digits of accuracy, e.g. 1e-4 requests accuracy to roughly 4 significant digits. (default: nothing)\nmaxiters: a soft upper limit on the number of integrand evaluations (default: typemax(Int))\n\nSolvers typically converge only to the weakest error condition. For example, a relative tolerance can be used in combination with a smaller-than necessary absolute tolerance so that the solution is resolved up to the requested significant digits, unless the integral is smaller than the absolute tolerance.\n\n\n\n\n\n","category":"function"},{"location":"problems/#AutoBZCore.init","page":"Problems","title":"AutoBZCore.init","text":"init(::IntegralProblem, ::IntegralAlgorithm; kws...)::IntegralCache\n\nConstruct a cache for an IntegralProblem, IntegralAlgorithm, and the keyword arguments to the solver (i.e. abstol, reltol, or maxiters) that can be reused for solving the problem for multiple different parameters of the same type.\n\n\n\n\n\n","category":"function"},{"location":"problems/#AutoBZCore.solve!","page":"Problems","title":"AutoBZCore.solve!","text":"solve!(::IntegralCache)::IntegralSolution\n\nCompute the solution to an IntegralProblem constructed from init.\n\n\n\n\n\n","category":"function"},{"location":"problems/#AutoBZCore.NullParameters","page":"Problems","title":"AutoBZCore.NullParameters","text":"NullParameters()\n\nA singleton type representing absent parameters\n\n\n\n\n\n","category":"type"},{"location":"problems/#Functor-interface","page":"Problems","title":"Functor interface","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"As shown in the quickstart of the AutoBZCore page, AutoBZCore.jl also defines a functor interface to solving integrals","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"AutoBZCore.IntegralSolver","category":"page"},{"location":"problems/#AutoBZCore.IntegralSolver","page":"Problems","title":"AutoBZCore.IntegralSolver","text":"IntegralSolver(f, dom, alg; [abstol, reltol, maxiters])\nIntegralSolver(f, lb, ub, alg::AbstractIntegralAlgorithm; [abstol, reltol, maxiters])\n\nReturns a functor, fun, that accepts input parameters p and solves the corresponding integral fun(p) -> solve(IntegralProblem(f, lb, ub, p), alg).u. See solve for details on the keywords.\n\nIf f is a ParameterIntegrand or FourierIntegrand, then the functor interface is modified to accept parameters as function arguments, and the following is done: fun(args...; kwargs...) ->  solve(IntegralProblem(f, lb, ub, merge(f.p, MixedParameters(args...; kwargs...))), alg).u where f.p are the preset parameters of f.\n\n\n\n\n\n","category":"type"},{"location":"problems/","page":"Problems","title":"Problems","text":"The functor interface is also extended by ParameterIntegrand and FourierIntegrand to allow a more flexible interface for passing (partial) positional and keyword arguments to user-defined integrands.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"AutoBZCore.MixedParameters\nAutoBZCore.paramzip\nAutoBZCore.paramproduct","category":"page"},{"location":"problems/#AutoBZCore.MixedParameters","page":"Problems","title":"AutoBZCore.MixedParameters","text":"MixedParameters(args::Tuple, kwargs::NamedTuple)\nMixedParameters(args...; kwargs...)\n\nA struct to store the arguments and keyword arguments to a function. Indicies access args, i.e. MixedParameters(args...; kwargs...)[i] == args[i] and properties access kwargs, i.e. MixedParameters(args...; kwargs...).name == kwargs.name.\n\nUsed internally to store partially complete collections of function arguments or parameters.\n\n\n\n\n\n","category":"type"},{"location":"problems/#AutoBZCore.paramzip","page":"Problems","title":"AutoBZCore.paramzip","text":"paramzip(args...; kwargs...)\n\nBehaves similarly to zip(zip(args...), zip(kwargs...)) with MixedParameters return values so that paramzip(args...; kwargs...)[i][j] == args[j][i] and paramzip(args...; kwargs...)[i].name == kwargs.name[i].\n\n\n\n\n\n","category":"function"},{"location":"problems/#AutoBZCore.paramproduct","page":"Problems","title":"AutoBZCore.paramproduct","text":"paramproduct(args...; kwargs...)\n\nBehaves similarly to product(args..., kwargs...) with MixedParameters return values so that paramzip(args...; kwargs...)[i1, ...,ij, il, ...in] == MixedParameters(args[begin][i1], ..., args[end][ij]; kwargs[begin][il], ..., kwargs[end][in])\n\n\n\n\n\n","category":"function"},{"location":"problems/#Batched-evaluation","page":"Problems","title":"Batched evaluation","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"The routine batchsolve allows multi-threaded evaluation of an IntegralSolver at many parameter points.","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"AutoBZCore.batchsolve","category":"page"},{"location":"problems/#AutoBZCore.batchsolve","page":"Problems","title":"AutoBZCore.batchsolve","text":"batchsolve(f::IntegralSolver, ps::AbstractArray, [T]; nthreads=Threads.nthreads())\n\nEvaluate the IntegralSolver f at each of the parameters ps in parallel. Returns an array similar to ps containing the evaluated integrals I. This is a form of multithreaded broadcasting. Providing the return type f(eltype(ps))::T is optional, but will help in case inference of that type fails.\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following are several examples of how to use the algorithms and integrands provided by AutoBZCore.jl. For background on defining integrals see the Problem definitions page","category":"page"},{"location":"examples/#Green's-function","page":"Examples","title":"Green's function","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"A common integral appearing in Dynamical mean-field theory is that of the local Green's function:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"G(omega) = int d^d veck operatornameTr left left( omega - H left( veck right) - Sigma(omega) right)^-1 right","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For simplicity, we take Sigma(omega) = -ieta. We can define the integrand as a function of veck and H and (required) parameters eta omega.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using LinearAlgebra\ngloc_integrand(k, h; η, ω) = inv(complex(ω,η)*I-h(k))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Commonly, H(veck) is evaluated using Wannier interpolation, i.e. as a Fourier series. For a simple tight-binding model, the integer lattice, the Hamiltonian is given by","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"H(k) = cos(2pi k) = frac12 left( e^2pi ik + e^-2pi ik right)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can use the built-in function cos to evaluate this, however, for more complex Fourier series it becomes easier to use the representation in terms of Fourier coefficients. Using the package FourierSeriesEvaluators.jl, we can define H(k) = cos(2pi k) by the following:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using FourierSeriesEvaluators\nh = FourierSeries([0.5, 0.0, 0.5]; period=1, offset=-2)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The coefficient values of 12 can be determined from Euler's formula, as used in the expansion of cos above, and the value of offset is chosen to offset the coefficient array indices, 1:3 since Julia has 1-based indexing, to correspond to values of n in the phase factors e^2pi i n k used in the Fourier series above, i.e. -1:1. Now we proceed to the define the integral problem","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AutoBZCore\nusing AutoBZCore: IntegralProblem\nintegrand = ParameterIntegrand(gloc_integrand, h, η=0.1)\nprob = IntegralProblem(integrand, 0, 1)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we wrapped our function with two of its arguments, h, η as a ParameterIntegrand that allows us to provide partial arguments so that we can solve the integral as a function of the remaining parameters, in this case ω. We also created an AutoBZCore.IntegralProblem to integrate our function over its period 01. To solve this problem, we pick any of the package's Integral algorithms and the tolerance to which we would like the solution. Then we make an IntegralSolver to evaluate G(omega) as a function.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"alg = QuadGKJL()\ngloc = IntegralSolver(prob, alg; abstol=1e-3)\ngloc(ω=0.0) # -2.7755575615628914e-17 - 0.9950375451895513im","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we proceed to multi-dimensional integrals. In this case, Wannier interpolation is much more efficient when Fourier series are evaluated one variable at a time. To understand, this suppose we have a series defined by M times M coefficients (i.e. a 2d series) that we want to evaluate on an N times N grid. Naively evaluating the series at each grid point will require mathcalO(M^2 N^2) operations, however, we can reduce the complexity by pre-evaluating certain coefficients as follows","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"f(x y) = sum_mn=1^M f_nm e^i(nx + my) = sum_n=1^M e^inx left( sum_m=1^M f_nm e^imy right) = sum_n=1^M e^inx tildef_n(y)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This means we can evaluate the series on the grid in mathcalO(M N^2 + M^2 N) operations. When N gg M, this is mathcalO(M N^2) operations, which is comparable to the computational complexity of a multi-dimensional FFT. Since the constants of a FFT may not be trivial, this scheme is competitive.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This capability is provided by FourierIntegrand. Let's use this with a Fourier series corresponding to H(veck) = cos(2pi k_x) + cos(2pi k_y)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"h = FourierSeries([0.0; 0.5; 0.0;; 0.5; 0.0; 0.5;; 0.0; 0.5; 0.0]; period=1, offset=-2)\nintegrand = FourierIntegrand(gloc_integrand, h, η=0.1)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"However, since FourierIntegrand evaluates H(k) for us and gives it as a FourierValue together with k, we need to define another method for our integrand to comply with the interface","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"gloc_integrand(h_k::FourierValue; η, ω) = inv(complex(ω,η)*I-h_k.s)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Similar to before, we construct an AutoBZCore.IntegralProblem and this time we take the integration domain to correspond to the full Brillouin zone of a square lattice with lattice vectors 2pi*I(2). (See the Reference for more details on constructing BZs.)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"bz = load_bz(FBZ(2), 2pi*I(2))\nprob = IntegralProblem(integrand, bz)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This package provides several BZ-specific integral algorithms that we can use to solve the multidimensional integral.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"alg = IAI()\ngloc = IntegralSolver(prob, alg; abstol=1e-3)\ngloc(ω=0.0) # 1.5265566588595902e-16 - 1.3941704019631334im","category":"page"},{"location":"examples/#Density-of-states","page":"Examples","title":"Density of states","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The repo's demo on density of states provides a complete example of how to compute and interpolate an integral as a function of its parameters.","category":"page"},{"location":"reference/#Function-reference","page":"Reference","title":"Function reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The following symbols are exported by AutoBZCore.jl","category":"page"},{"location":"reference/#Domains","page":"Reference","title":"Domains","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"AutoBZCore.PuncturedInterval\nAutoBZCore.HyperCube\nAutoBZCore.load_bz\nAutoBZCore.SymmetricBZ","category":"page"},{"location":"reference/#AutoBZCore.PuncturedInterval","page":"Reference","title":"AutoBZCore.PuncturedInterval","text":"PuncturedInterval(s)\n\nRepresent an interval (a, b) with interior points deleted by s = (a, c1, ..., cN, b), so that the integration algorithm can avoid the points c1, ..., cN for e.g. discontinuities. s must be a tuple or vector.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.HyperCube","page":"Reference","title":"AutoBZCore.HyperCube","text":"HyperCube(a, b)\n\nRepresents a hypercube spanned by the vertices a, b, which must be iterables of the same length.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.load_bz","page":"Reference","title":"AutoBZCore.load_bz","text":"load_bz(bz::AbstractBZ, [T::Type=Float64])\nload_bz(bz::AbstractBZ, A::AbstractMatrix, [B::AbstractMatrix])\n\nInterface to loading Brillouin zones.\n\nArguments\n\nbz::AbstractBZ: a kind of Brillouin zone to construct, e.g. FBZ or IBZ\nT::Type: a numeric type to set the precision of the domain (default: Float64)\nA::AbstractMatrix: a d times d matrix whose columns are the real-space lattice vectors of a d-dimensional crystal\nB::AbstractMatrix: a d times d matrix whose columns are the reciprocal-space lattice vectors of a d-dimensional Brillouin zone (default: A' \\ 2πI)\n\n!!! note \"Assumptions\" AutoBZCore assumes that all calculations occur in the reciprocal     lattice basis, since that is the basis in which Wannier interpolants are most     efficiently described. See SymmetricBZ for details. We also assume that the     integrands are cheap to evaluate, which is why we provide adaptive methods in the first     place, so that return types can be determined at runtime (and mechanisms are in place     for compile time as well)\n\n\n\n\n\n","category":"function"},{"location":"reference/#AutoBZCore.SymmetricBZ","page":"Reference","title":"AutoBZCore.SymmetricBZ","text":"SymmetricBZ(A, B, lims::AbstractIteratedLimits, syms; atol=sqrt(eps()))\n\nData type representing a Brillouin zone reduced by a set of symmetries, syms with iterated integration limits lims, both of which are assumed to be in the lattice basis (since the Fourier series is). A and B should be identically-sized square matrices containing the real and reciprocal basis vectors in their columns.\n\nnote: Convention\nThis type assumes all integration limit data is in the reciprocal lattice basis with fractional coordinates, where the FBZ is just the hypercube spanned by the vertices (0,…,0) & (1,…,1). If necessary, use A or B to rotate these quantities into the convention.\n\nlims should be limits compatible with IteratedIntegration.jl. syms should be an iterable collection of point group symmetries compatible with AutoSymPTR.jl.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Brillouin-zone-kinds","page":"Reference","title":"Brillouin-zone kinds","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"AutoBZCore.AbstractBZ\nAutoBZCore.FBZ\nAutoBZCore.IBZ\nAutoBZCore.InversionSymIBZ\nAutoBZCore.CubicSymIBZ","category":"page"},{"location":"reference/#AutoBZCore.AbstractBZ","page":"Reference","title":"AutoBZCore.AbstractBZ","text":"AbstractBZ{d}\n\nAbstract supertype for all Brillouin zone data types parametrized by dimension.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.FBZ","page":"Reference","title":"AutoBZCore.FBZ","text":"FBZ{N} <: AbstractBZ\n\nSingleton type representing first/full Brillouin zones of N dimensions. By default, N is nothing and the dimension is obtained from input files.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.IBZ","page":"Reference","title":"AutoBZCore.IBZ","text":"IBZ <: AbstractBZ\n\nSingleton type representing irreducible Brillouin zones. Load SymmetryReduceBZ.jl to use this.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.InversionSymIBZ","page":"Reference","title":"AutoBZCore.InversionSymIBZ","text":"InversionSymIBZ{N} <: AbstractBZ\n\nSingleton type representing Brillouin zones with full inversion symmetry\n\nwarning: Assumptions\nOnly expect this to work for systems with orthogonal lattice vectors\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.CubicSymIBZ","page":"Reference","title":"AutoBZCore.CubicSymIBZ","text":"CubicSymIBZ{N} <: AbstractBZ\n\nSingleton type representing Brillouin zones with full cubic symmetry\n\nwarning: Assumptions\nOnly expect this to work for systems with orthogonal lattice vectors\n\n\n\n\n\n","category":"type"},{"location":"reference/#Symmetry-representations","page":"Reference","title":"Symmetry representations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"AutoBZCore.AbstractSymRep\nAutoBZCore.SymRep\nAutoBZCore.TrivialRep\nAutoBZCore.UnknownRep\nAutoBZCore.symmetrize_","category":"page"},{"location":"reference/#AutoBZCore.AbstractSymRep","page":"Reference","title":"AutoBZCore.AbstractSymRep","text":"AbstractSymRep\n\nAbstract supertype of symmetry representation traits.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.SymRep","page":"Reference","title":"AutoBZCore.SymRep","text":"SymRep(f)\n\nSymRep specifies the symmetry representation of the integral of the function f. When you define a new integrand, you can choose to implement this trait to specify how the integral is transformed under the symmetries of the lattice in order to map the integral of f on the IBZ to the result for the FBZ.\n\nNew types for SymRep should also extend a corresponding method for AutoBZCore.symmetrize_.\n\n\n\n\n\n","category":"function"},{"location":"reference/#AutoBZCore.TrivialRep","page":"Reference","title":"AutoBZCore.TrivialRep","text":"TrivialRep()\n\nSymmetry representation of objects with trivial transformation under the group.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.UnknownRep","page":"Reference","title":"AutoBZCore.UnknownRep","text":"UnknownRep()\n\nFallback symmetry representation for array types without a user-defined SymRep.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AutoBZCore.symmetrize_","page":"Reference","title":"AutoBZCore.symmetrize_","text":"symmetrize_(rep::AbstractSymRep, bz::SymmetricBZ, x)\n\nTransform x under representation rep using the symmetries in bz to obtain the result of an integral on the FBZ from x, which was calculated on the IBZ.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Internal","page":"Reference","title":"Internal","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The following docstrings belong to internal functions that may change between versions of AutoBZCore.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"AutoBZCore.trapz\nAutoBZCore.cube_automorphisms\nAutoBZCore.batchparam\nAutoBZCore.symmetrize\nAutoBZCore.FourierValue","category":"page"},{"location":"reference/#AutoBZCore.trapz","page":"Reference","title":"AutoBZCore.trapz","text":"trapz(n::Integer)\n\nReturn the weights and nodes on the standard interval [-1,1] of the trapezoidal rule.\n\n\n\n\n\n","category":"function"},{"location":"reference/#AutoBZCore.cube_automorphisms","page":"Reference","title":"AutoBZCore.cube_automorphisms","text":"cube_automorphisms(::Val{d}) where d\n\nreturn a generator of the symmetries of the cube in d dimensions including the identity.\n\n\n\n\n\n","category":"function"},{"location":"reference/#AutoBZCore.batchparam","page":"Reference","title":"AutoBZCore.batchparam","text":"batchparam(ps, nthreads)\n\nIf the cost of a calculation smoothly varies with the parameters ps, then batch ps into nthreads groups where the ith element of group j is ps[j+(i-1)*nthreads] along the longest axis of ps. We assume that multidimensional arrays of parameters have smoothest cost along their longest axis\n\n\n\n\n\n","category":"function"},{"location":"reference/#AutoBZCore.symmetrize","page":"Reference","title":"AutoBZCore.symmetrize","text":"symmetrize(f, ::SymmetricBZ, xs...)\nsymmetrize(f, ::SymmetricBZ, x::Union{Number,AbstractArray{<:Any,0}})\n\nTransform x by the symmetries of the parametrization used to reduce the domain, thus mapping the value of x on the parametrization to the full domain.\n\n\n\n\n\n","category":"function"},{"location":"reference/#AutoBZCore.FourierValue","page":"Reference","title":"AutoBZCore.FourierValue","text":"FourierValue(x, s)\n\nA container used by FourierIntegrand to pass a point, x, and the value of a Fourier series evaluated at the point, s, to integrands. The properties x and s of a FourierValue store the point and evaluated series, respectively.\n\n\n\n\n\n","category":"type"},{"location":"#AutoBZCore.jl","page":"Home","title":"AutoBZCore.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"note: Work in progress\nWe apologize for the inconvenience as we continue improving the documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"AutoBZCore","category":"page"},{"location":"#AutoBZCore","page":"Home","title":"AutoBZCore","text":"A package providing a common interface to integration algorithms intended for applications including Brillouin-zone integration and Wannier interpolation. Its design is influenced by high-level libraries like Integrals.jl, and it makes use of Julia's multiple dispatch to provide the same interface for integrands with optimized inplace, batched, and Fourier series evaluation.\n\nQuickstart\n\nAs a first example, we integrate sine over [0,1] as a function of its period.\n\njulia> using AutoBZCore\n\njulia> f = IntegralSolver((x,p) -> sin(p*x), 0, 1, QuadGKJL());\n\njulia> f(0.3) # solves the integral of sin(p*x) over [0,1] with p=0.3\n0.14887836958131329\n\nNotice that we construct an IntegralSolver object that we can evaluate at different parameters with a function-like interface. For more examples, see the documentation.\n\nFeatures\n\nSpecial integrand interfaces\n\nParameterIntegrand: allows user integrand to use keyword arguments\nInplaceIntegrand: allows an integrand to write its result inplace to an array\nBatchIntegrand: allows user-side parallelization on e.g. shared memory, distributed memory, or the gpu\nFourierIntegrand: efficient evaluation of Fourier series for cubatures with hierachical grids\n\nQuadrature algorithms:\n\nTrapezoidal rule and FastGaussQuadrature.jl: QuadratureFunction\nh-adaptive quadrature (Gauss-Kronrod): QuadGKJL\nh-adaptive cubature (Genz-Malik): HCubatureJL\np-adaptive, symmetrized Monkhorst-Pack: AutoSymPTRJL\n\nMeta-Algorithms:\n\nIterated integration: NestedQuad\nIntegrand evaluation counter: EvalCounter\n\nExtended help\n\nIf you experience issues with AutoBZCore.jl, please report a bug on the GitHub page to contact the developers.\n\n\n\n\n\n","category":"module"},{"location":"algorithms/#Integral-algorithms","page":"Algorithms","title":"Integral algorithms","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"AutoBZCore.IntegralAlgorithm","category":"page"},{"location":"algorithms/#AutoBZCore.IntegralAlgorithm","page":"Algorithms","title":"AutoBZCore.IntegralAlgorithm","text":"IntegralAlgorithm\n\nAbstract supertype for integration algorithms.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#Quadrature","page":"Algorithms","title":"Quadrature","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"AutoBZCore.QuadratureFunction\nAutoBZCore.QuadGKJL\nAutoBZCore.AuxQuadGKJL\nAutoBZCore.ContQuadGKJL\nAutoBZCore.MeroQuadGKJL","category":"page"},{"location":"algorithms/#AutoBZCore.QuadratureFunction","page":"Algorithms","title":"AutoBZCore.QuadratureFunction","text":"QuadratureFunction(; fun=trapz, npt=50, nthreads=Threads.nthreads())\n\nQuadrature rule for the standard interval [-1,1] computed from a function x, w = fun(npt). The nodes and weights should be set so the integral of f on [-1,1] is sum(w .* f.(x)). The default quadrature rule is trapz, although other packages provide rules, e.g.\n\nusing FastGaussQuadrature\nalg = QuadratureFunction(fun=gausslegendre, npt=100)\n\nnthreads sets the numbers of threads used to parallelize the quadrature only when the integrand is a BatchIntegrand, in which case the user must parallelize the integrand evaluations. For no threading set nthreads=1.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.QuadGKJL","page":"Algorithms","title":"AutoBZCore.QuadGKJL","text":"QuadGKJL(; order = 7, norm = norm)\n\nDuplicate of the QuadGKJL provided by Integrals.jl.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.AuxQuadGKJL","page":"Algorithms","title":"AutoBZCore.AuxQuadGKJL","text":"AuxQuadGKJL(; order = 7, norm = norm)\n\nGeneralization of the QuadGKJL provided by Integrals.jl that allows for AuxValued integrands for auxiliary integration and multi-threaded evaluation with the batch argument to IntegralProblem\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.ContQuadGKJL","page":"Algorithms","title":"AutoBZCore.ContQuadGKJL","text":"ContQuadGKJL(; order = 7, norm = norm, rho = 1.0, rootmeth = IteratedIntegration.ContQuadGK.NewtonDeflation())\n\nA 1d contour deformation quadrature scheme for scalar, complex-valued integrands. It defaults to regular quadgk behavior on the real axis, but if it finds a root of 1/f nearby, in the sense of Bernstein ellipse for the standard segment [-1,1] with semiaxes cosh(rho) and sinh(rho), on either the upper/lower half planes, then it dents the contour away from the presumable pole.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.MeroQuadGKJL","page":"Algorithms","title":"AutoBZCore.MeroQuadGKJL","text":"MeroQuadGKJL(; order = 7, norm = norm, rho = 1.0, rootmeth = IteratedIntegration.MeroQuadGK.NewtonDeflation())\n\nA 1d pole subtraction quadrature scheme for scalar, complex-valued integrands that are meromorphic. It defaults to regular quadgk behavior on the real axis, but if it finds nearby roots of 1/f, in the sense of Bernstein ellipse for the standard segment [-1,1] with semiaxes cosh(rho) and sinh(rho), it attempts pole subtraction on that segment.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#Cubature","page":"Algorithms","title":"Cubature","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"AutoBZCore.HCubatureJL\nAutoBZCore.MonkhorstPack\nAutoBZCore.AutoSymPTRJL","category":"page"},{"location":"algorithms/#AutoBZCore.HCubatureJL","page":"Algorithms","title":"AutoBZCore.HCubatureJL","text":"HCubatureJL(; norm=norm, initdiv=1)\n\nA copy of HCubatureJL from Integrals.jl.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.MonkhorstPack","page":"Algorithms","title":"AutoBZCore.MonkhorstPack","text":"MonkhorstPack(; npt=50, syms=nothing, nthreads=Threads.nthreads())\n\nPeriodic trapezoidal rule with a fixed number of k-points per dimension, npt, using the PTR rule from AutoSymPTR.jl. nthreads sets the numbers of threads used to parallelize the quadrature only when the integrand is a BatchIntegrand, in which case the user must parallelize the integrand evaluations. For no threading set nthreads=1. The caller should check that the integral is converged w.r.t. npt.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.AutoSymPTRJL","page":"Algorithms","title":"AutoBZCore.AutoSymPTRJL","text":"AutoSymPTRJL(; norm=norm, a=1.0, nmin=50, nmax=1000, n₀=6, Δn=log(10), keepmost=2, nthreads=Threads.nthreads())\n\nPeriodic trapezoidal rule with automatic convergence to tolerances passed to the solver with respect to norm using the routine autosymptr from AutoSymPTR.jl. nthreads sets the numbers of threads used to parallelize the quadrature only when the integrand is a BatchIntegrand, in which case the user must parallelize the integrand evaluations. For no threading set nthreads=1. This algorithm is the most efficient for smooth integrands.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#Meta-algorithms","page":"Algorithms","title":"Meta-algorithms","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"AutoBZCore.NestedQuad\nAutoBZCore.EvalCounter\nAutoBZCore.AbsoluteEstimate","category":"page"},{"location":"algorithms/#AutoBZCore.NestedQuad","page":"Algorithms","title":"AutoBZCore.NestedQuad","text":"NestedQuad(alg::IntegralAlgorithm)\nNestedQuad(algs::IntegralAlgorithm...)\n\nNested integration by repeating one quadrature algorithm or composing a list of algorithms. The domain of integration must be an AbstractIteratedLimits from the IteratedIntegration.jl package. Analogous to nested_quad from IteratedIntegration.jl. The integrand should expect SVector inputs. Do not use this for very high-dimensional integrals, since the compilation time scales very poorly with respect to dimensionality. In order to improve the compilation time, FunctionWrappers.jl is used to enforce type stability of the integrand, so you should always pick the widest integration limit type so that inference works properly. For example, if ContQuadGKJL is used as an algorithm in the nested scheme, then the limits of integration should be made complex.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.EvalCounter","page":"Algorithms","title":"AutoBZCore.EvalCounter","text":"EvalCounter(::IntegralAlgorithm)\n\nAn algorithm which counts the evaluations used by another algorithm. The count is stored in the sol.numevals field.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.AbsoluteEstimate","page":"Algorithms","title":"AutoBZCore.AbsoluteEstimate","text":"AbsoluteEstimate(est_alg, abs_alg; kws...)\n\nMost algorithms are efficient when using absolute error tolerances, but how do you know the size of the integral? One option is to estimate it using second algorithm.\n\nA multi-algorithm to estimate an integral using an est_alg to generate a rough estimate of the integral that is combined with a user's relative tolerance to re-calculate the integral to higher accuracy using the abs_alg. The keywords passed to the algorithm may include reltol, abstol and maxiters and are given to the est_alg solver. They should limit the amount of work of est_alg so as to only generate an order-of-magnitude estimate of the integral. The tolerances passed to abs_alg are abstol=max(abstol,reltol*norm(I)) and reltol=0.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#BZ-specific-integral-algorithms","page":"Algorithms","title":"BZ-specific integral algorithms","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"In order to make algorithms domain-agnostic, the BZ loaded from load_bz can be called with the algorithms below, which are wrappers for algorithms above with the additional capability of mapping integrals over the IBZ to the FBZ.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"AutoBZCore.AutoBZAlgorithm\nAutoBZCore.IAI\nAutoBZCore.TAI\nAutoBZCore.PTR\nAutoBZCore.AutoPTR\nAutoBZCore.PTR_IAI\nAutoBZCore.AutoPTR_IAI","category":"page"},{"location":"algorithms/#AutoBZCore.AutoBZAlgorithm","page":"Algorithms","title":"AutoBZCore.AutoBZAlgorithm","text":"AutoBZAlgorithm\n\nAbstract supertype for Brillouin zone integration algorithms. All integration problems on the BZ get rescaled to fractional coordinates so that the Brillouin zone becomes [0,1]^d, and integrands should have this periodicity. If the integrand depends on the Brillouin zone basis, then it may have to be transformed to the Cartesian coordinates as a post-processing step.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.IAI","page":"Algorithms","title":"AutoBZCore.IAI","text":"IAI(alg::IntegralAlgorithm=AuxQuadGKJL())\nIAI(algs::IntegralAlgorithm...)\n\nIterated-adaptive integration using nested_quad from IteratedIntegration.jl. This algorithm is the most efficient for localized integrands.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.TAI","page":"Algorithms","title":"AutoBZCore.TAI","text":"TAI(; norm=norm, initdivs=1)\n\nTree-adaptive integration using hcubature from HCubature.jl. This routine is limited to integration over hypercube domains and may not use all symmetries.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.PTR","page":"Algorithms","title":"AutoBZCore.PTR","text":"PTR(; npt=50, parallel=nothing)\n\nPeriodic trapezoidal rule with a fixed number of k-points per dimension, npt, using the routine ptr from AutoSymPTR.jl. The caller should check that the integral is converged w.r.t. npt.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.AutoPTR","page":"Algorithms","title":"AutoBZCore.AutoPTR","text":"AutoPTR(; norm=norm, a=1.0, nmin=50, nmax=1000, n₀=6, Δn=log(10), keepmost=2, parallel=nothing)\n\nPeriodic trapezoidal rule with automatic convergence to tolerances passed to the solver with respect to norm using the routine autosymptr from AutoSymPTR.jl. This algorithm is the most efficient for smooth integrands.\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#AutoBZCore.PTR_IAI","page":"Algorithms","title":"AutoBZCore.PTR_IAI","text":"PTR_IAI(; ptr=PTR(), iai=IAI())\n\nMulti-algorithm that returns an IAI calculation with an abstol determined from the given reltol and a PTR estimate, I, as reltol*norm(I). This addresses the issue that IAI does not currently use a globally-adaptive algorithm and may not have the expected scaling with localization length unless an abstol is used since computational effort may be wasted via a reltol with the naive nested_quadgk.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#AutoBZCore.AutoPTR_IAI","page":"Algorithms","title":"AutoBZCore.AutoPTR_IAI","text":"AutoPTR_IAI(; reltol=1.0, ptr=AutoPTR(), iai=IAI())\n\nMulti-algorithm that returns an IAI calculation with an abstol determined from an AutoPTR estimate, I, computed to reltol precision, and the rtol given to the solver as abstol=rtol*norm(I). This addresses the issue that IAI does not currently use a globally-adaptive algorithm and may not have the expected scaling with localization length unless an abstol is used since computational effort may be wasted via a reltol with the naive nested_quadgk.\n\n\n\n\n\n","category":"function"}]
}
